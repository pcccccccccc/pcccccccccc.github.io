{"pages":[{"title":"About","text":"Pemp软件工程@南京大学 Coldplay&amp;旅行&amp;平权主义🌈 wx: pemppeng (请注明来意)","link":"/about/index.html"}],"posts":[{"title":"STL简介","text":"C++ STL教程所有常用操作都在代码里STL可能会很慢，时间允许的话可替代操作还是手写好建议对每一种都盲敲2~3遍代码，不要眼高手低 Vector1234567891011121314#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;//！！！头文件using namespace std;vector&lt;int&gt; a[100];int main(){ for(int i=1;i&lt;=200;i++) a[1].push_back(i);//插入 a[1].pop_back();//弹出 cout&lt;&lt;a[1].size()&lt;&lt;endl;//大小 for(int i=0;i&lt;199;i++) cout&lt;&lt;a[1][i]&lt;&lt;endl; } MapMap是c++的一个标准容器，按字面意思就是地图的意思即给你一个元素，根据“地图”找到这个元素对应的元素 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 /*头文件&lt;map&gt;*/#include &lt;map&gt;#include &lt;iostream&gt;using namespace std;int main(){ map&lt;string,int&gt; a; cout&lt;&lt;&quot;插入:&quot;&lt;&lt;endl; a[&quot;April&quot;]=112;//插入 cout&lt;&lt;a[&quot;April&quot;]&lt;&lt;endl; cout&lt;&lt;endl; cout&lt;&lt;&quot;查询:&quot;&lt;&lt;endl; map&lt;string,int&gt;::iterator pc;//查询一个元素是否在map里 pc=a.find(&quot;April&quot;); if(pc==a.end()) cout&lt;&lt;&quot;Not Find&quot;&lt;&lt;endl;//如果找不到会自动返回“指向map尾部的迭代器” else cout&lt;&lt;pc-&gt;second&lt;&lt;endl;//输出&quot;April&quot;对应的键值 cout&lt;&lt;endl; cout&lt;&lt;&quot;遍历&quot;&lt;&lt;endl; a[&quot;June&quot;]=1;//遍历 a[&quot;July&quot;]=2; map&lt;string,int&gt;::iterator i; for(i=a.begin(); i!=a.end(); i++)//不能等于a.end() { cout&lt;&lt;i-&gt;second&lt;&lt;endl; } cout&lt;&lt;endl; cout&lt;&lt;&quot;判断map是否是空集&quot;&lt;&lt;endl; cout&lt;&lt;a.empty()&lt;&lt;endl;//判断map是否是空集 cout&lt;&lt;endl; cout&lt;&lt;&quot;交换两个map的元素 &quot;&lt;&lt;endl; map&lt;int ,int&gt; b;//交换两个map的元素 map&lt;int ,int&gt; c; c[1]=1; c[2]=2; b[1]=1000; swap(b,c); map&lt;int,int&gt; ::iterator j; for(j=b.begin();j!=b.end();j++) { cout&lt;&lt;j-&gt;second&lt;&lt;endl; } for(j=c.begin();j!=c.end();j++) { cout&lt;&lt;j-&gt;second&lt;&lt;endl; } } map中 swap的用法： Map中的swap不是一个容器中的元素交换，而是两个容器交换； Map中的元素是自动按key升序排序 123456789101112131415161718192021222324252627 #include &lt;map&gt; #include &lt;iostream&gt; using namespace std; int main( ) { map &lt;int, int&gt; m1; map &lt;int, int&gt;::iterator m1_Iter; m1[1]=20; m1[4]=40; m1[3]=60; m1[2]=50; m1[6]=40; m1[7]=30; cout &lt;&lt; &quot;The original map m1 is:&quot;&lt;&lt;endl; for ( m1_Iter = m1.begin( ); m1_Iter != m1.end( ); m1_Iter++ ) cout &lt;&lt; m1_Iter-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;m1_Iter-&gt;second&lt;&lt;endl;}/*The original map m1 is: 1 20 2 50 3 60 4 40 6 40 7 30*/ map的基本操作函数： 12345678910111213141516171819begin() 返回指向map头部的迭代器clear(） 删除所有元素count() 返回指定元素出现的次数empty() 如果map为空则返回trueend() 返回指向map末尾的迭代器*equal_range() 返回特殊条目的迭代器对erase() 删除一个元素find() 查找一个元素get_allocator() 返回map的配置器insert() 插入元素key_comp() 返回比较元素key的函数lower_bound() 返回键值&gt;=给定元素的第一个位置max_size() 返回可以容纳的最大元素个数rbegin() 返回一个指向map尾部的逆向迭代器rend() 返回一个指向map头部的逆向迭代器size() 返回map中元素的个数swap() 交换两个mapupper_bound() 返回键值&gt;给定元素的第一个位置value_comp() 返回比较元素value的函数 Set set作为一个容器也是用来存储同一数据类型的数据类型，并且能从一个数据集合中取出数据，在set中每个元素的值都唯一，而且系统能根据元素的值自动进行排序。应该注意的是set中数元素的值不能直接被改变。 set中常用的方法 1234567begin() 返回set容器的第一个元素end() 返回set容器的最后一个元素clear() 删除set容器中的所有的元素empty() 判断set容器是否为空size() 返回当前set容器中的元素个数count() 用来查找set中某个某个键值出现的次数。这个函数在set并不是很实用，因为一个键值在set只可能出现0或1次，这样就变成了判断某一键值是否在set出现过了。find() ，返回给定值值得定位器，如果没找到则返回end()。 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int main(){ set&lt;int&gt; s; s.insert(1); s.insert(2); s.insert(3); s.insert(1); cout&lt;&lt;&quot;set 的 size 值为 ：&quot;&lt;&lt;s.size()&lt;&lt;endl; cout&lt;&lt;&quot;set 的 maxsize的值为 ：&quot;&lt;&lt;s.max_size()&lt;&lt;endl; cout&lt;&lt;&quot;set 中的第一个元素是 ：&quot;&lt;&lt;*s.begin()&lt;&lt;endl; cout&lt;&lt;&quot;set 中的最后一个元素是:&quot;&lt;&lt;*s.end()&lt;&lt;endl; s.clear(); if(s.empty()) { cout&lt;&lt;&quot;set 为空 ！！！&quot;&lt;&lt;endl; } cout&lt;&lt;&quot;set 的 size 值为 ：&quot;&lt;&lt;s.size()&lt;&lt;endl; cout&lt;&lt;&quot;set 的 maxsize的值为 ：&quot;&lt;&lt;s.max_size()&lt;&lt;endl; return 0;} lower_bound(key_value) ，返回第一个大于等于key_value的定位器 upper_bound(key_value)，返回最后一个大于等于key_value的定位器 12345678910111213141516#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int main(){ set&lt;int&gt; s; s.insert(1); s.insert(3); s.insert(4); cout&lt;&lt;*s.lower_bound(2)&lt;&lt;endl; cout&lt;&lt;*s.lower_bound(3)&lt;&lt;endl; cout&lt;&lt;*s.upper_bound(3)&lt;&lt;endl; return 0;} useful link about set Queue普通队列大家都会写吧 我们来看看如何用queue来实现堆的功能 1234567891011121314151617//小根堆 #include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q;//默认是大根堆，小根堆需要自己加greater&lt;int&gt;int main(){ q.push(1); q.push(2); q.push(3); while(q.size()) { cout&lt;&lt;q.top()&lt;&lt;endl; q.pop(); }} 1234567891011121314151617//大根堆 #include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;priority_queue&lt;int&gt;q;int main(){ q.push(1); q.push(2); q.push(3); while(q.size()) { cout&lt;&lt;q.top()&lt;&lt;endl; q.pop(); }} Bitsetbitset可以看作bool数组，但优化了空间复杂度和时间复杂度，并且可以像整型一样按位与或。 123456789101112131415161718#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;bitset&gt;using namespace std;bitset&lt;10&gt; a;//&lt;&gt;中间是长度！！！bitset&lt;10&gt; b;int main(){ a.set();//全部置为1 cout&lt;&lt;a&lt;&lt;endl; a.reset();//全部置为0 a[1]=1;//可以直接把它当作一个数来进行二进制操作 a=a|b; cout&lt;&lt;a.count()&lt;&lt;endl; //输出bitset里有多少个1 cout&lt;&lt;a&lt;&lt;endl; a.flip();//将bitset里的元素翻转一下 cout&lt;&lt;a;} &lt;&gt;中间是长度！！！ bitset空间占用十分小，运行速度也很快！！奇技淫巧 常用的成员函数： 12345678910111213141516b.any() b中是否存在置为1的二进制位？b.none() b存在置为1的二进制位吗？b.count() b中置为1的二进制位的个数b.size() b中二进制位数的个数b[pos] 访问b中在pos处二进制位b.test(pos) b中在pos处的二进制位置为1么？b.set() 把b中所有二进制位都置为1b.set(pos) 把b中在pos处的二进制位置为1b.reset( ) 把b中所有二进制位都置为0b.reset( pos ) 把b中在pos处的二进制位置置为0b.flip( ) 把b中所有二进制位逐位取反b.flip( pos ) 把b中在pos处的二进制位取反b.to_ulong( ) 把b中同样的二进制位返回一个unsignedb._Find_next(pos) 返回bitset在位置pos之后第一个1的位置 useful link about Bitset lower_bound&amp;upper_bound 函数lower_bound()在first和last中的前闭后开区间进行二分查找，返回大于或等于**val的第一个元素位置。如果所有元素都小于val，则返回last的位置用法： int t=lower_bound(a+l,a+r,m)-a 函数upper_bound()在first和last中的前闭后开区间进行二分查找，返回大于val的第一个元素位置。如果所有元素都小于val，则返回last的位置复杂度O(logn)","link":"/2021/07/30/STL/"},{"title":"剧&amp;电影","text":"在看 Girl From Nowhere S1 Stranger Things S1 Dark S1 看过 Why Women Kill S2 👍👍👍 Girl From Nowhere S2 👍👍👍 Killing Eve S1-3 👍👍👍👍👍 A Quiet Place: Part 2 👍👍👍👍 F9: The Fast Saga 🤮🤮🤮 El inocente 👍👍👍👍 我的姐姐 👍👍👍 Godzilla vs Kong 👍👍👍 Persischstunden 👍👍👍👍 The End of the Fucking World S1-2 👍👍👍👍👍 Behind Her Eyes 👍👍👍👍 WandaVision 👍👍👍👍👍 Nomadland 👍👍👍👍 The Queen’s Gambit 👍👍👍👍👍 The Boys in the Band 👍👍👍👍 Sense8 👍👍👍👍👍 Love, Victor 👍👍👍👍 Chernobyl 👍👍👍👍 Call Me By Your Name 👍👍👍👍👍","link":"/2021/08/04/%E6%9C%80%E8%BF%91%E5%9C%A8%E7%9C%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E5%89%A7/"},{"title":"noip模板","text":"noip时期的一些板子 数据结构线段树1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int N=1e5;int n,m,tot,root;struct Tree{ int l,r,ls,rs,sum,max,tag;}t[N*2];void push_up(int x){ int L=t[x].ls,R=t[x].rs; t[x].sum=t[L].sum+t[R].sum; t[x].max=max(t[L].max,t[R].max);}void push_down(int x){ if(t[x].tag) { int L=t[x].ls,R=t[x].rs,T=t[x].tag;t[x].tag=0; t[L].sum+=(t[L].r-t[L].l+1)*T;t[L].max+=T;t[L].tag+=T; t[R].sum+=(t[R].r-t[R].l+1)*T;t[R].max+=T;t[R].tag+=T; }}void Build(int &amp;x,int L,int R){ x=++tot; t[x].l=L;t[x].r=R; if(L==R) {scanf(&quot;%d&quot;,&amp;t[x].sum);t[x].max=t[x].sum;return;} int mid=(L+R)&gt;&gt;1; Build(t[x].ls,L,mid); Build(t[x].rs,mid+1,R); push_up(x);}void Change(int x,int pos,int key){ if(t[x].l==t[x].r) {t[x].sum=t[x].max=key;return;} push_down(x); int mid=(t[x].l+t[x].r)&gt;&gt;1; if(pos&lt;=mid) Change(t[x].ls,pos,key); else Change(t[x].rs,pos,key); push_up(x);}void Add(int x,int L,int R,int key){ if(L&lt;=t[x].l&amp;&amp;R&gt;=t[x].r) {t[x].sum+=(t[x].r-t[x].l+1)*key;t[x].max+=key;t[x].tag+=key;return;} push_down(x); int mid=(t[x].l+t[x].r)&gt;&gt;1; if(L&lt;=mid) Add(t[x].ls,L,R,key); if(mid&lt;R) Add(t[x].rs,L,R,key); push_up(x);}int Sum(int x,int L,int R){ if(L&lt;=t[x].l&amp;&amp;R&gt;=t[x].r) return t[x].sum; push_down(x); int mid=(t[x].l+t[x].r)&gt;&gt;1,sum=0; if(L&lt;=mid) sum+=Sum(t[x].ls,L,R); if(R&gt;mid) sum+=Sum(t[x].rs,L,R); return sum;}int Max(int x,int L,int R){ if(L&lt;=t[x].l&amp;&amp;R&gt;=t[x].r) return t[x].max; push_down(x); int mid=(t[x].l+t[x].r)&gt;&gt;1,mx=0; if(L&lt;=mid) mx=max(mx,Max(t[x].ls,L,R)); if(R&gt;mid) mx=max(mx,Max(t[x].rs,L,R)); return mx;}int main(){ freopen(&quot;tree.in&quot;,&quot;r&quot;,stdin); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); Build(root,1,n); for(int i=1,t,x,y,z;i&lt;=m;i++) { scanf(&quot;%d&quot;,&amp;t); if(t==1) scanf(&quot;%d%d&quot;,&amp;x,&amp;y),Change(1,x,y); else if(t==2) scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z),Add(1,x,y,z); else if(t==3) scanf(&quot;%d%d&quot;,&amp;x,&amp;y),printf(&quot;%d\\n&quot;,Sum(1,x,y)); else scanf(&quot;%d%d&quot;,&amp;x,&amp;y),printf(&quot;%d\\n&quot;,Max(1,x,y)); }} 树链剖分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;iostream&gt;#include&lt;cstdio&gt;const int N=30010;int n,Q,ans,tot,dep[N],fa[N],size[N],son[N],top[N],pos[N],a[N];int head[N],next[N*2],to[N*2];struct node{ int l,r,ls,rs,max,sum;}t[N*2];void Dfs(int x){ dep[x]=dep[fa[x]]+1;size[x]=1; for(int e=head[x],y=to[e];e;y=to[e=next[e]]) if(y!=fa[x]) { fa[y]=x;Dfs(y); size[x]+=size[y]; if(size[y]&gt;size[son[x]]) son[x]=y; }}void Dfs(int x,int f){ pos[x]=++tot;top[x]=f; if(son[x]) Dfs(son[x],f); for(int e=head[x],y=to[e];e;y=to[e=next[e]]) if(y!=fa[x]&amp;&amp;y!=son[x]) Dfs(y,y);}void push_up(int x){ int L=t[x].ls,R=t[x].rs; t[x].sum=t[L].sum+t[R].sum; t[x].max=std::max(t[L].max,t[R].max);}void Build(int x,int l,int r){ t[x].l=l;t[x].r=r; if(l==r) { t[x].max=t[x].sum=a[l];return; } int mid=(l+r)&gt;&gt;1; Build(t[x].ls=++tot,l,mid); Build(t[x].rs=++tot,mid+1,r); push_up(x);}void Change(int x,int num,int key){ if(t[x].l==t[x].r) { t[x].max=t[x].sum=key;return; } int mid=(t[x].l+t[x].r)&gt;&gt;1; if(num&lt;=mid) Change(t[x].ls,num,key); else Change(t[x].rs,num,key); push_up(x);}int Max(int x,int L,int R){ if(L&lt;=t[x].l&amp;&amp;R&gt;=t[x].r) return t[x].max; int mid=(t[x].l+t[x].r)&gt;&gt;1,num=-30001; if(L&lt;=mid) num=std::max(num,Max(t[x].ls,L,R)); if(R&gt;mid) num=std::max(num,Max(t[x].rs,L,R)); return num;}int Sum(int x,int L,int R){ if(L&lt;=t[x].l&amp;&amp;R&gt;=t[x].r) return t[x].sum; int mid=(t[x].l+t[x].r)&gt;&gt;1,num=0; if(L&lt;=mid) num+=Sum(t[x].ls,L,R); if(R&gt;mid) num+=Sum(t[x].rs,L,R); return num;}int GetMax(int x,int y){ for(ans=-30001;top[x]!=top[y];x=fa[top[x]]) { if(dep[top[x]]&lt;dep[top[y]]) std::swap(x,y); ans=std::max(ans,Max(1,pos[top[x]],pos[x])); } if(pos[x]&gt;pos[y]) std::swap(x,y); return std::max(ans,Max(1,pos[x],pos[y]));}int GetSum(int x,int y){ for(ans=0;top[x]!=top[y];x=fa[top[x]]) { if(dep[top[x]]&lt;dep[top[y]]) std::swap(x,y); ans+=Max(1,pos[top[x]],pos[x]); } if(pos[x]&gt;pos[y]) std::swap(x,y); return ans+Max(1,pos[x],pos[y]);}int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1,ecnt=0,x,y;i&lt;n;i++) { scanf(&quot;%d%d&quot;,&amp;x,&amp;y); to[++ecnt]=y;next[ecnt]=head[x];head[x]=ecnt; to[++ecnt]=x;next[ecnt]=head[y];head[y]=ecnt; } Dfs(1);Dfs(1,1); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[pos[i]]); Build(tot=1,1,n); scanf(&quot;%d&quot;,&amp;Q);char s[10]; for(int i=1,x,y;i&lt;=Q;i++) { scanf(&quot;%s%d%d&quot;,s,&amp;x,&amp;y); if(s[0]=='C') Change(1,pos[x],y); else if(s[1]=='M') printf(&quot;%d\\n&quot;,GetMax(x,y)); else printf(&quot;%d\\n&quot;,GetSum(x,y)); }} SBT123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;cstdio&gt;using namespace std;const int N=1e5+5;int tot,root,key[N],size[N],son[N][2];void Rotate(int &amp;x,bool flag) //0-&gt;left_rotate 1-&gt;right_rotate{ int y=son[x][!flag]; son[x][!flag]=son[y][flag]; son[y][flag]=x; size[y]=size[x]; size[x]=size[son[x][0]]+size[son[x][1]]+1; x=y;}void Maintain(int &amp;x,bool flag) //0-&gt;ls 1-&gt; rs{ if(size[son[son[x][flag]][flag]]&gt;size[son[x][!flag]]) Rotate(x,!flag); else if(size[son[son[x][flag]][!flag]]&gt;size[son[x][!flag]]) Rotate(son[x][flag],flag),Rotate(x,!flag); else return; Maintain(son[x][0],0); Maintain(son[x][1],1); Maintain(x,1); Maintain(x,0); }void Insert(int &amp;x,int y){ if(!x) { x=++tot; key[x]=y; size[x]=1; son[x][0]=son[x][1]=0; return; } size[x]++; if(y&lt;=key[x]) Insert(son[x][0],y); else Insert(son[x][1],y); Maintain(x,y&gt;key[x]);}int Delete(int &amp;x,int y){ size[x]--; if((y&lt;key[x]&amp;&amp;!son[x][0])||(y&gt;key[x]&amp;&amp;!son[x][1])) return 0; if(y==key[x]) { int ans=key[x]; if(!son[x][0]||!son[x][1]) x=son[x][0]+son[x][1]; else { int k=son[x][0]; while(son[k][1]) k=son[k][1]; key[x]=Delete(son[x][0],key[k]); } return ans; } if(y&lt;key[x]) return Delete(son[x][0],y); else return Delete(son[x][1],y);}int Find(int x,int y){ if(!x) return 0; if(y==key[x]) return 1; else if(y&lt;key[x]) return Find(son[x][0],y); else return Find(son[x][1],y);}int Rank(int x,int y){ if(!x) return 1; else if(y&lt;=key[x]) return Rank(son[x][0],y); else return size[son[x][0]]+1+Rank(son[x][1],y);}int Kth(int x,int y){ if(y==size[son[x][0]]+1) return key[x]; else if(y&lt;=size[son[x][0]]) return Kth(son[x][0],y); else return Kth(son[x][1],y-size[son[x][0]]-1);}int Pred(int &amp;x,int y){ if(!x) return y; if(y&lt;=key[x]) return Pred(son[x][0],y); else { int ans=Pred(son[x][1],y); if(y==ans) return key[x]; else return ans; }}int Succ(int &amp;x,int y){ if(!x) return y; if(y&gt;=key[x]) return Succ(son[x][1],y); else { int ans=Succ(son[x][0],y); if(y==ans) return key[x]; else return ans; }}void Inorder(int x){ if(x) { Inorder(son[x][0]); printf(&quot;%d &quot;,key[x]); Inorder(son[x][1]); }}int main(){ freopen(&quot;sbt.in&quot;,&quot;r&quot;,stdin); int x,y; while(scanf(&quot;%d%d&quot;,&amp;x,&amp;y)!=EOF) { if(x==1) Insert(root,y); else if(x==2) Delete(root,y); else if(x==3) printf(&quot;%d\\n&quot;,Find(root,y)); else if(x==4) printf(&quot;%d\\n&quot;,Rank(root,y)); else if(x==5) printf(&quot;%d\\n&quot;,Kth(root,y)); else if(x==6) printf(&quot;%d\\n&quot;,Pred(root,y)); else printf(&quot;%d\\n&quot;,Succ(root,y)); //if(x&lt;=2) Inorder(root),printf(&quot;\\n&quot;); }} splay123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;cstdio&gt;const int N=1e5+5;int tot,root,size[N],num[N],key[N],fa[N],son[N][2];void push_up(int x){ size[x]=size[son[x][0]]+size[son[x][1]]+num[x];}void Rotate(int x){ //push_down(fa[x]);push_down(x); int y=fa[x],z=fa[y],t=(son[y][0]==x); if(z) son[z][son[z][1]==y]=x;fa[x]=z; son[y][!t]=son[x][t];fa[son[y][!t]]=y; son[x][t]=y;fa[y]=x; push_up(y);push_up(x);}void Splay(int x,int f){ while(fa[x]!=f) { int y=fa[x],z=fa[y]; if(z!=f) { if(son[z][0]==y^son[y][0]==x) Rotate(x); else Rotate(y); } Rotate(x); } if(!f) root=x;}void Insert(int &amp;x,int v,int f){ if(!x) { x=++tot; son[x][0]=son[x][1]=0; size[x]=num[x]=1; key[x]=v;fa[x]=f; Splay(x,0); return; } if(v==key[x]) { num[x]++;size[x]++; Splay(x,0); return; } Insert(son[x][v&gt;key[x]],v,x); push_up(x);}int Get(int v){ int x=root; while(x&amp;&amp;v!=key[x]) x=son[x][v&gt;key[x]]; return x;}void Delete(int x){ x=Get(x);if(!x) return; Splay(x,0); if(num[x]&gt;1) {num[x]--;size[x]--;return;} if(!son[x][0]||!son[x][1]) root=son[x][0]+son[x][1]; else { int y=son[x][1];while(son[y][0]) y=son[y][0]; Splay(y,x); son[y][0]=son[x][0];fa[son[y][0]]=y; root=y; } fa[root]=0; push_up(root);}int Rank(int v){ Insert(root,v,0); int ans=size[son[root][0]]+1; Delete(v); return ans;}int Kth(int x){ int y=root; while(x&lt;=size[son[y][0]]||x&gt;size[son[y][0]]+num[y]) { if(x&lt;=size[son[y][0]]) y=son[y][0]; else x-=size[son[y][0]]+num[y],y=son[y][1]; } return key[y];}int Pred(int v){ Insert(root,v,0); int x=son[root][0];while(son[x][1]) x=son[x][1]; Delete(v); return key[x];}int Succ(int v){ Insert(root,v,0); int x=son[root][1];while(son[x][0]) x=son[x][0]; Delete(v); return key[x];}void Inorder(int x){ if(son[x][0]) Inorder(son[x][0]); for(int i=1;i&lt;=num[x];i++) printf(&quot;%d &quot;,key[x]); if(son[x][1]) Inorder(son[x][1]);}int main(){ for(int x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y)!=EOF;) { if(x==1) Insert(root,y,0); else if(x==2) Delete(y); else if(x==3) printf(&quot;%d\\n&quot;,Get(y)); else if(x==4) printf(&quot;%d\\n&quot;,Rank(y)); else if(x==5) printf(&quot;%d\\n&quot;,Kth(y)); else if(x==6) printf(&quot;%d\\n&quot;,Pred(y)); else printf(&quot;%d\\n&quot;,Succ(y)); //if(x&lt;=2) Inorder(root),printf(&quot;\\n&quot;); }} LCT1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;#include &lt;cstdio&gt;const int N=1e5;int n,m,fa[N],son[N][2],size[N],key[N],sum[N],max[N],tag[N],rev[N];inline bool isroot(int x){ return son[fa[x]][0]!=x&amp;&amp;son[fa[x]][1]!=x;}inline void Add(int x,int v){ key[x]+=v;sum[x]+=v*size[x];max[x]+=v;tag[x]+=v;}inline void push_up(int x){ size[x]=size[son[x][0]]+size[son[x][1]]+1; sum[x]=sum[son[x][0]]+sum[son[x][1]]+key[x]; max[x]=std::max(std::max(max[son[x][0]],max[son[x][1]]),key[x]);}inline void push_down(int x){ if(rev[x]) rev[x]^=1,rev[son[x][0]]^=1,rev[son[x][1]]^=1,std::swap(son[x][0],son[x][1]); if(tag[x]) Add(son[x][0],tag[x]),Add(son[x][1],tag[x]),tag[x]=0;}inline void Rotate(int x){ push_down(fa[x]);push_down(x); int y=fa[x],z=fa[y],t=(son[y][0]==x); if(!isroot(y)) son[z][son[z][1]==y]=x;fa[x]=z; son[y][!t]=son[x][t];fa[son[y][!t]]=y; son[x][t]=y;fa[y]=x; push_up(y);push_up(x);}inline void Splay(int x){ push_down(x); while(!isroot(x)) { int y=fa[x],z=fa[y]; if(!isroot(y)) { if(son[z][0]==y^son[y][0]==x) Rotate(x); else Rotate(y); } Rotate(x); }}inline void Access(int x) //将x到root的路径变成实路径{ for(int y=0;x;y=x,x=fa[x]) Splay(x),son[x][1]=y,push_up(x);}inline void Makeroot(int x) //将x变为root{ Access(x);Splay(x);rev[x]^=1;}inline void Split(int x,int y) //将x到y的路径放入splay，x为根{ Makeroot(x);Access(y);Splay(x);}inline void Link(int x,int y){ Makeroot(x);fa[x]=y;}inline void Cut(int x,int y){ Split(x,y);son[x][1]=fa[y]=0;}inline int Find(int x) //找到x所在树的root{ Access(x);Splay(x);while(son[x][0]) x=son[x][0];return x;}int main(){ max[0]=-0x7fffffff; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1,x;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;x),size[i]=1,Add(i,x),tag[i]=0; for(int i=1,opt,x,y,z;i&lt;=m;i++) { scanf(&quot;%d%d%d&quot;,&amp;opt,&amp;x,&amp;y); if(opt==1) Link(x,y); else if(opt==2) Cut(x,y); else if(opt==3) Splay(x),key[x]=y,push_up(x); //更改x的权值为y else if(opt==4) Split(x,y),printf(&quot;%d\\n&quot;,max[x]); //求x到y路径上的最大值 else if(opt==5) Split(x,y),printf(&quot;%d\\n&quot;,sum[x]); //求x到y路径上的和 else if(opt==6) printf(&quot;%d\\n&quot;,Find(x)==Find(y)); //判断x和y是否连通 else scanf(&quot;%d&quot;,&amp;z),Split(x,y),Add(x,z); //将x到y路径上加z }} 主席树123456789101112131415161718192021222324252627282930313233#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;const int N=100005;int n,m,tot,totn,a[N],b[N],root[N],size[N*20],ls[N*20],rs[N*20];void Insert(int l,int r,int x,int &amp;y,int v){ y=++tot; size[y]=size[x]+1; ls[y]=ls[x];rs[y]=rs[x]; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(v&lt;=mid) Insert(l,mid,ls[x],ls[y],v); else Insert(mid+1,r,rs[x],rs[y],v);}int Quary(int l,int r,int x,int y,int v){ if(l==r) return l; int mid=(l+r)&gt;&gt;1,k=size[ls[y]]-size[ls[x]]; if(v&lt;=k) return Quary(l,mid,ls[x],ls[y],v); else return Quary(mid+1,r,rs[x],rs[y],v-k);}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),b[i]=a[i]; sort(b+1,b+n+1); totn=unique(b+1,b+n+1)-b-1; for(int i=1;i&lt;=n;i++) Insert(1,totn,root[i-1],root[i],lower_bound(b+1,b+totn+1,a[i])-b); for(int i=1,x,y,z;i&lt;=m;i++) scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z),printf(&quot;%d\\n&quot;,b[Quary(1,totn,root[x-1],root[y],z)]);} 网络流Dinic12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int N=5005,M=10005;int n,m,S,T,ans,ecnt=1,ds[N],head[N],to[M&lt;&lt;1],rest[M&lt;&lt;1],next[M&lt;&lt;1];queue&lt;int&gt; Q;void Addedge(int x,int y,int z){ to[++ecnt]=y;rest[ecnt]=z;next[ecnt]=head[x];head[x]=ecnt; to[++ecnt]=x;rest[ecnt]=0;next[ecnt]=head[y];head[y]=ecnt;}bool Bfs(){ for(int i=0;i&lt;=T;i++) ds[i]=0; Q.push(S);ds[S]=1; while(!Q.empty()) { int x=Q.front();Q.pop(); for(int e=head[x],y=to[e];e;e=next[e],y=to[e]) if(rest[e]&amp;&amp;!ds[y]) ds[y]=ds[x]+1,Q.push(y); } return ds[T];}int Dfs(int x,int flow){ if(x==T) return flow; int a=0,b; for(int e=head[x],y=to[e];e;e=next[e],y=to[e]) if(rest[e]&amp;&amp;ds[y]==ds[x]+1) { b=Dfs(y,min(flow-a,rest[e])); rest[e]-=b;rest[e^1]+=b;a+=b; if(a==flow) break; } if(!a) ds[x]=0; return a;}int main(){ scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;S,&amp;T); for(int i=1,x,y,z;i&lt;=m;i++) scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z),Addedge(x,y,z); while(Bfs()) ans+=Dfs(S,0x7fffffff); printf(&quot;%d\\n&quot;,ans);} MCF12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int inf=0x3fffffff;const int N=100;const int M=2000;int n,m,S,T,ds[N],pre[N],maxflow,mincost;int ecnt=1,st[N],to[M*2],rest[M*2],cost[M*2],next[M*2];bool used[N];queue&lt;int&gt; Q;void Addedge(int x,int y,int r,int c){ to[++ecnt]=y;rest[ecnt]=r;cost[ecnt]=c;next[ecnt]=st[x];st[x]=ecnt; to[++ecnt]=x;rest[ecnt]=0;cost[ecnt]=-c;next[ecnt]=st[y];st[y]=ecnt;}bool Spfa(){ for(int i=0;i&lt;=T;i++) ds[i]=inf; Q.push(S);ds[S]=0;used[S]=1; while(!Q.empty()) { int x=Q.front();Q.pop();used[x]=0; for(int e=st[x],y=to[e];e;e=next[e],y=to[e]) if(rest[e]&amp;&amp;ds[y]&gt;ds[x]+cost[e]) { ds[y]=ds[x]+cost[e]; pre[y]=e; if(!used[y]) used[y]=1,Q.push(y); } } return ds[T]&lt;inf;}void Update(int flow){ for(int e=pre[T];e;e=pre[to[e^1]]) flow=min(flow,rest[e]); for(int e=pre[T];e;e=pre[to[e^1]]) rest[e]-=flow,rest[e^1]+=flow; maxflow+=flow;mincost+=flow*ds[T];}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); S=1;T=n; for(int i=1,u,v,r,c;i&lt;=n;i++) scanf(&quot;%d%d%d%d&quot;,&amp;u,&amp;v,&amp;r,&amp;c),Addedge(u,v,r,c); while(Spfa()) Update(inf); printf(&quot;Maxflow:%d\\nMinflow:%d\\n&quot;,maxflow,mincost);} 字符串KMP12345678910111213141516171819202122232425262728#include&lt;cstring&gt;#include&lt;cstdio&gt;int n,m,next[100001];char a[100001],b[100001];void Getnext(){ next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) { while(j!=-1&amp;&amp;b[i]!=b[j]) j=next[j]; next[i+1]=j+1; }}void KMP(){ for(int i=0,j=0;i&lt;n;i++,j++) { while(j!=-1&amp;&amp;a[i]!=b[j]) j=next[j]; if(j==m-1) printf(&quot;%d\\n&quot;,i-j+1); }}int main(){ scanf(&quot;%s%s&quot;,a,b); //a-&gt;long b-&gt;short n=strlen(a);m=strlen(b); Getnext(); KMP();} 后缀数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;const int base=29;int n,sa[10001];char s[10001];unsigned long long ha[10001],power[10001]={1};inline unsigned long long HASH(int l,int r){ return ha[r]-ha[l-1]*power[r-l+1];}inline int LCP(int x,int y){ int l=0,r=std::min(n-x+1,n-y+1),mid; while(l&lt;r) { mid=(l+r+1)&gt;&gt;1; if(HASH(x,x+mid-1)==HASH(y,y+mid-1)) l=mid; else r=mid-1; } return l;}inline bool cmp(int x,int y){ int z=LCP(x,y);return s[x+z]&lt;s[y+z];}int main(){ scanf(&quot;%s&quot;,s+1); n=strlen(s+1); for(int i=1;i&lt;=n;i++) ha[i]=ha[i-1]*base+s[i]-'a'+1,power[i]=power[i-1]*base,sa[i]=i; std::sort(sa+1,sa+n+1,cmp); for(int i=2;i&lt;=n;i++) height[i]=LCP(sa[i-1],sa[i]);}3.3 AC自动机#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;const int N=500005;int T,n,tot,end[N],fail[N],son[N][26];char s[N*2];std::queue&lt;int&gt; Q;inline void init(int x){ end[x]=0; for(int i=0;i&lt;26;i++) son[x][i]=0;}inline void Add(){ scanf(&quot;%s&quot;,s); int len=strlen(s),pre=0; for(int i=0;i&lt;len;i++) { if(!son[pre][s[i]-'a']) init(son[pre][s[i]-'a']=++tot); pre=son[pre][s[i]-'a']; } end[pre]++;}inline void Build(){ Q.push(0); while(!Q.empty()) { int x=Q.front();Q.pop(); for(int i=0;i&lt;26;i++) { if(son[x][i]) { Q.push(son[x][i]); fail[son[x][i]]=x?son[fail[x]][i]:0; } else son[x][i]=x?son[fail[x]][i]:0; } }}inline int Calc(){ scanf(&quot;%s&quot;,s); int len=strlen(s),pre=0,ans=0; for(int i=0;i&lt;len;i++) { pre=son[pre][s[i]-'a']; for(int j=pre;j;j=fail[j]) ans+=end[j],end[j]=0; } return ans;}int main(){ scanf(&quot;%d&quot;,&amp;T); while(T--) { init(tot=0); for(scanf(&quot;%d&quot;,&amp;n);n;n--) Add(); Build(); printf(&quot;%d\\n&quot;,Calc()); }} Manacher1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;int n,m,maxpos,maxlen,len[200001];char s[100001],a[200001];int main(){ scanf(&quot;%s&quot;,s); n=strlen(s); for(int i=0;i&lt;n;i++) a[m++]='#',a[m++]=s[i]; a[m++]='#';maxlen=-1; for(int i=0,j;i&lt;m;i++) { j=std::min(len[maxpos*2-i],maxlen-i)*(i&lt;=maxlen); while(i-j&gt;=0&amp;&amp;i+j&lt;=m&amp;&amp;a[i-j]==a[i+j]) j++; len[i]=j-1; if(i+j&gt;maxlen) maxpos=i,maxlen=i+j; } for(int i=0;i&lt;m;i++) printf(&quot;%d &quot;,len[i]);} 回文树1234567891011121314151617181920212223242526272829303132333435#include &lt;cstring&gt;#include &lt;cstdio&gt; using namespace std;const int N=1e6;int n,LEN,tot,last,son[N][26],fail[N],len[N],num[N];char s[N];inline int newnode(int l){ len[++tot]=l; return tot;}inline int getnode(int x){ while(s[n-len[x]-1]!=s[n]) x=fail[x]; return x;}inline void Add(int c){ int cnt=getnode(last); if(!son[cnt][c]) { int now=newnode(len[cnt]+2); fail[now]=son[getnode(fail[cnt])][c]; son[cnt][c]=now; } num[last=son[cnt][c]]++;}int main(){ scanf(&quot;%s&quot;,s+1); LEN=strlen(s+1); newnode(-1);fail[0]=1; while(++n&lt;=LEN) Add(s[n]-'a'); for(int i=tot;i&gt;=2;i--) num[fail[i]]+=num[i];} 其他STLTarjan12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdio&gt;const int N=1e4+5;const int M=1e5+5;int n,m,dfsnum,tot,top,ecnt,st[N],dfn[N],low[N],pos[N],head[N],to[M],next[M];bool vis[N];inline void Addedge(int x,int y){ to[++ecnt]=y;next[ecnt]=head[x];head[x]=ecnt;}inline void Tarjan(int x){ dfn[x]=low[x]=++dfsnum; vis[x]=1; st[++top]=x; for(int e=head[x],y=to[e];e;y=to[e=next[e]]) if(!dfn[y]) Tarjan(y),low[x]=std::min(low[x],low[y]); else if(vis[y]) low[x]=std::min(low[x],dfn[y]); /*{//A一个奇怪的写法 if(!dfn[y]) Tarjan(y); if(vis[y]) low[x]=std::min(low[y],low[x]); }*/ if(dfn[x]==low[x]) { tot++; for(int y;y!=x;) { y=st[top--]; pos[y]=tot; vis[y]=0; } }}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1,x,y;i&lt;=m;i++) scanf(&quot;%d%d&quot;,&amp;x,&amp;y),Addedge(x,y); for(int i=1;i&lt;=n;i++) if(!dfn[i]) Tarjan(i);} 数学exgcd12345678910111213141516171819#include &lt;cstdio&gt;using namespace std;int a,b,c,d,x,y;inline void exgcd(int a,int b,int &amp;d,int &amp;x,int &amp;y){ if(!b) d=a,x=1,y=0; else exgcd(b,a%b,d,y,x),y-=a/b*x;}int main(){ scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); exgcd(a,b,d,x,y); if(!(c%d)) { x*=c/d;y*=c/d;a/=d;b/=d; for(int k=-2;k&lt;=2;k++) printf(&quot;%d %d\\n&quot;,x+k*b,y-k*a); }} 欧拉筛法12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;const int N=101;int tot,prime[N],not_p[N],phi[N],d[N],e[N],mu[N];int main(){ not_p[1]=1;d[1]=1;mu[1]=1; for(int i=2;i&lt;N;i++) { if(!not_p[i]) { prime[++tot]=i; phi[i]=i-1; d[i]=2; e[i]=1; mu[i]=-1; } for(int j=1,k=2*i;j&lt;=tot&amp;&amp;k&lt;N;k=prime[++j]*i) { not_p[k]=1; if(i%prime[j]) { phi[k]=phi[i]*phi[prime[j]]; d[k]=d[i]*d[prime[j]]; e[k]=1; mu[k]=-mu[i]; } else { phi[k]=phi[i]*prime[j]; d[k]=d[i]/(e[i]+1)*(e[i]+2); e[k]=e[i]+1; mu[k]=0; break; } } }} 矩阵乘法12345678910111213141516#include &lt;cstring&gt;#include &lt;cstdio&gt;struct Matrix{ int m[11][11],W,H;};Matrix operator * (const Matrix a,const Matrix b) //默认a.W==b.H{ Matrix c; c.H=a.H;c.W=b.W; memset(c.m,0,sizeof(c.m)); for(int i=1;i&lt;=c.H;i++) for(int j=1;j&lt;=c.W;j++) for(int k=1;k&lt;=a.W;k++) c.m[i][j]+=a.m[i][k]*b.m[k][j]; return c;} 高斯消元12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdio&gt;const int N=1001;int n,m,line,row,a[N][N+1],sure[N];inline int gcd(int x,int y){ return !y?x:gcd(y,x%y);}inline int Guass(){ for(line=row=1;line&lt;=n&amp;&amp;row&lt;=m;line++,row++) //line-&gt;hang row-&gt;lie { int t=line;while(t&lt;=n&amp;&amp;!a[t][row]) t++; if(t&gt;n) {line--;continue;} if(t!=line) std::swap(a[t],a[line]); for(int i=1;i&lt;=n;i++) if(i!=line&amp;&amp;a[i][row]) { int d=gcd(a[i][row],a[line][row]); int ta=a[line][row]/d,tb=a[i][row]/d; for(int j=line;j&lt;=m+1;j++) a[i][j]=a[i][j]*ta-a[line][j]*tb; } } line--;row--; for(int i=line+1;i&lt;=n;i++) if(a[i][m+1]) return -1; if(line&lt;m) { for(int i=1;i&lt;=m;i++) sure[i]=-1; for(int i=line;i;i--) { int cnt=0,num; for(int j=1;j&lt;=m;j++) if(a[i][j]&amp;&amp;sure[j]==-1) cnt++,num=j; if(cnt==1) sure[num]=a[i][m+1]; } return 1; } return 0;}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m+1;j++) scanf(&quot;%d&quot;,&amp;a[i][j]); Guass();} 凸包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;const int N=1e5+5;const double eps=1e-6;int n,top;double len,S;struct Point { double x,y; } a[N],b[N];double dis(Point x,Point y){ return sqrt((x.x-y.x)*(x.x-y.x)+(x.y-y.y)*(x.y-y.y));}double Cross(Point x,Point y,Point z){ return (x.x-z.x)*(y.y-z.y)-(x.y-z.y)*(y.x-z.x);}double Cross(Point x,Point y){ return x.x*y.y-x.y*y.x;}bool cmp(const Point &amp;x,const Point &amp;y){ double t=Cross(x,y,a[1]);return abs(t)&gt;eps?t&gt;0:dis(a[1],x)&lt;dis(a[1],y);}inline void Graham(){ int t=1; for(int i=2;i&lt;=n;i++) if(a[i].x&lt;a[t].x||(a[i].x==a[t].x&amp;&amp;a[i].y&lt;a[t].y)) t=i; if(t!=1) std::swap(a[t],a[1]); std::sort(a+2,a+n+1,cmp); for(int i=1;i&lt;=n;i++) { while(top&gt;1&amp;&amp;Cross(a[i],b[top],b[top-1])&gt;=0) top--; b[++top]=a[i]; } b[top+1]=b[1];}int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%lf%lf&quot;,&amp;a[i].x,&amp;a[i].y); Graham(); for(int i=1;i&lt;=top;i++) len+=dis(b[i],b[i+1]); printf(&quot;L: %.8lf\\n&quot;,len); for(int i=1;i&lt;=top;i++) S+=Cross(b[i],b[i+1]); printf(&quot;S: %.8lf\\n&quot;,S/2);} 求质因子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;inline int power(int a,int b,int P){ int c=1; for(;b;b&gt;&gt;=1,a=(long long)a*a%P) if(b&amp;1) c=(long long)c*a%P; return c;}inline bool Prime(int base,int x){ if(base==x) return 1; for(int i=x-1;;i&gt;&gt;=1) { int y=power(base,i,x); if(y==x-1) return 1; if(y!=1) return 0; if(i&amp;1) return 1; }}inline bool Miller_Rabin(int x){ if(x==2) return 1; else if(x&lt;2||!(x&amp;1)) return 0; for(int i=1;i&lt;=10;i++) if(!Prime(rand()%(x-1)+1,x)) return 0; return 1;} inline int gcd(int x,int y){ return !y?x:gcd(y,x%y);}inline int Pollard_rho(int n,int a){ for(int i=1,k=1,x=rand()%n,y=x;;i++) { x=((long long)x*x%n+a)%n; int d=gcd(abs(y-x),n); if(d&gt;1&amp;&amp;d&lt;n) return d; if(x==y) return n; if(i==k) y=x,k&lt;&lt;=1; }}inline void findfac(int n){ if(Miller_Rabin(n)) { printf(&quot;%d &quot;,n);return; } int p=n; while(p&gt;=n) p=Pollard_rho(p,rand()%(n-1)+1); findfac(p);findfac(n/p);}int main(){ std::srand(time(NULL)); int n; while(scanf(&quot;%d&quot;,&amp;n)) findfac(n),printf(&quot;\\n&quot;);} 常见算法读入优化1234567int read(){ int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();} return x*f;} 快速幂1234567int power(int a,int b,int P){ int re=1; for(;b;b&gt;&gt;=1,a=(long long)a*a%P) if(b&amp;1) re=(long long)re*a%P; return re;} 筛法 O(n)prime 素数phi φ 不大于x且与x互质的数的个数d x的正约数的个数e x的最小质因数的个数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const int N = 100 + 1;int prime[N], e[N], d[N], tot, phi[N];bool not_p[N];inline void pre(){ not_p[1] = 1; d[1] = 1; for(int i = 2; i &lt; N; ++i) { if(!not_p[i]) { prime[++tot] = i; e[i] = 1; d[i] = 2; phi[i] = i - 1; } for(int j = 1; j &lt;= tot; ++j) { int k = prime[j] * i; if(k &gt; N) break; not_p[k] = 1; if(i % prime[j]) { d[k] = d[i] * d[prime[j]]; e[k] = 1; phi[k] = phi[i] * phi[prime[j]]; } else{ d[k] = d[i] / (e[i] + 1) * (e[i] + 2); e[k] = e[i] + 1; phi[k] = phi[i] * prime[j]; break; } } }}//单独求欧拉函数 LL Phi(LL x){ LL i,re=x; for(i=2;i*i&lt;=x;i++) if(x%i==0) { re/=i; re*=i-1; while(x%i==0) x/=i; } if(x!=1) re/=x,re*=(x-1); return re;} ged&amp;&amp;exgcd O(logn)函数求出ax+by=gcd(a,b)的其中一组解ax+by=c的解就是x×c/d,y×c/d（当然如果c%d!=0的话，无整数解）∴p×a+q×b=c的其他整数解满足：xx = x+b/d×tyy = y-a/d×t (t∈Z) gcd1234int gcd(int a,int b){ return b==0?a:gcd(b,a%b);} exgcd12345int exgcd(int a,int b,int &amp;d,int &amp;x,int &amp;y){ if(!b) { d=a; x=1; y=0; } else { exgcd(b,a%b,d,y,x); y-=x*(a/b); }} kmp O(n)M 短串，长度为mT 长串，长度为n 123456789101112131415161718int KMP(){ for(int i=0,j=0;i&lt;n;i++,j++) { while(j!=-1&amp;&amp;W[j]!=T[i]) j=next[j]; if(j==m-1) return i-m+2; }}void getNext(){ next[0]=-1; for(int i=1;i&lt;m;i++) for(int j=next[i];j&gt;=0;j=next[j]) if(W[j]==W[i]) { next[i+1]=j+1;break; }} 背包问题01背包123456789for(int i=1;i&lt;=n;i++) for(int v=0;v&lt;=m;v++) { if(v-w[i]&gt;=0) f[i][v]=max(f[i-1][v],f[i-1][v-w[i]]+c[i]); else f[i][v]=f[i-1][v]; }for(int i=1;i&lt;=n;i++) for(int v=m;v&gt;=w[i];v--) f[v]=max(f[v],f[v-w[i]]+c[i]); 完全背包优化：拆成w[i]*2^k , c[i]*2^k 的若干件（其中w[i]*2^k&lt;V） 123456789for(int i=1;i&lt;=n;i++) for(int v=0;v&lt;=m;v++) { if(v-w[i]&gt;=0) f[i][v]=max(f[i-1][v],f[i][v-w[i]]+c[i]); else f[i][v]=f[i-1][v]; } for(int i=1;i&lt;=n;i++) for(int v=w[i];v&lt;=m;v++) f[v]=max(f[v],f[v-w[i]]+c[i]); 多重背包优化：拆成1,2,4,…, 2^(k-1) , n[i]-2^k+1 （其中k为满足n[i]-x^k+1&gt;0的最大整数) 1234567891011121314for(int i=1;i&lt;=n;i++) for(int v=0;v&lt;=m;v++) for(int k=0;k&lt;=num[i];k++) { f[i][v]=max(f[i][v],f[i-1][v]); if(v-k*w[i]&gt;=0) f[i][v]=max(f[i][v],f[i-1][v-k*w[i]]+k*c[i]); }for(int i=1;i&lt;=n;i++) for(int v=m;v&gt;=0;v--) for(int k=0;k&lt;=num[i];k++) { if(v-k*w[i]&lt;0) break; f[v]=max(f[v],f[v-k*w[i]]+k*c[i]); } 离散化12345678int main(){ map&lt;int,int&gt;m; for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,b[i]); sort(b+1,b+n+1); b[0]=unique(b+1,b+n+1)-(b+1); for(int j=1;j&lt;=b[0];j++) m[b[j]]=j;} 并查集12345678int father(int x){ return fa[x]==x?x:fa[x]=father(fa[x]);}int unionn(int x,int y){ fa[father(x)]=father(y);} 最短路SPFA O(kE)123456789101112131415161718memset(ds,0x7f,sizeof(ds));ds[S]=0; vis[S]=1; q.push(S);while(!q.empty()){ int x=q.front(); q.pop(); vis[x]=0; for(int i=0;i&lt;to[x].size();i++) { int y=to[x][i],c=cost[x][i]; if(ds[y]&gt;ds[x]+c) { ds[y]=ds[x]+c; if(!vis[y]) { vis[y]=1; q.push(y); } } }} Dijkstra O(n*logn)1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int N=10005;const int M=100005;const int inf=0x7fffffff;int st[N],next[2*M],ed[2*M],cost[2*M],tot,ds[N],n,m;inline void add(int x,int y,int z){ next[++tot]=st[x],st[x]=tot,ed[tot]=y,cost[tot]=z;}struct node{ int x,d; inline node(int a,int b):x(a),d(b){} inline bool operator&lt;(const node&amp;t) const{return d&gt;t.d;}};priority_queue&lt;node&gt; q;int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1,x,y,z;i&lt;=m;i++) { scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); add(x,y,z); add(y,x,z); } int S=1,T=n; for(int i=1;i&lt;=n;i++) ds[i]=inf; q.push(node(S,0)); while(!q.empty()){ node x=q.top(); q.pop(); if(ds[x.x]&lt;inf) continue; ds[x.x]=x.d; for(int now=st[x.x];now;now=next[now]) q.push(node(ed[now],x.d+cost[now])); } printf(&quot;%d\\n&quot;,ds[T]);} 最小生成树Kruskal O(E*logE)1234567891011121314151617181920212223242526272829303132#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;int n,m,x,y,z,f1,f2,tot,k,fa[1001];struct node{ int x,y,v;}a[10001];int cmp(const node &amp;a,const node &amp;b){ return a.v&lt;b.v;}int father(int x){ return fa[x]==x?x:fa[x]=father(fa[x]);}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) fa[i]=i; for(int i=1;i&lt;=m;i++) scanf(&quot;%d%d%d&quot;,&amp;a[i].x,&amp;a[i].y,&amp;a[i].v); sort(a+1,a+m+1,cmp); for(int i=1;i&lt;=m;i++) { x=a[i].x;y=a[i].y;z=a[i].v; f1=father(x);f2=father(y); if(f1==f2) continue; fa[f1]=f2;tot+=z;k++; if(k==n-1) break; } printf(&quot;%d&quot;,tot);} Prim1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;int n,m,x,y,z,tot,ans,k,ds[1001],next[2001],st[1001],to[2001],cost[2001];bool vis[1001];void addedge(int x,int y,int z){ next[++tot]=st[x];st[x]=tot;to[tot]=y;cost[tot]=z;}struct node{ int x,d; node(int a,int b):x(a),d(b) {} bool operator&lt;(const node&amp;t) const {return d&gt;t.d;}}; priority_queue&lt;node&gt;q;int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); addedge(x,y,z);addedge(y,x,z); } memset(ds,0x7f,sizeof(ds)); ds[1]=0;q.push(node(1,0));vis[0]=1; for(int i=1;i&lt;=n;i++) { node a(0,0); while(vis[a.x]&amp;&amp;!q.empty()) a=q.top(),q.pop(); if(vis[a.x]) break; ans+=a.d;vis[a.x]=1;k++; for(int j=st[a.x];j;j=next[j]) { y=to[j];z=cost[j]; if(!vis[y]&amp;&amp;z&lt;ds[y]) ds[y]=z,q.push(node(y,z)); } } if(k!=n) printf(&quot;-1&quot;); else printf(&quot;%d&quot;,ans);} 线段树 O(nlogn)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int N=100;struct node{ int lc,rc,l,r,sum;}t[2*N]; int root,tot;int a[N];void build(int x,int l,int r){ t[x].l=l; t[x].r=r; if(l==r) { t[x].sum=a[l]; return; } int mid=(l+r)/2; t[x].lc=++tot; build(t[x].lc,l,mid); t[x].rc=++tot; build(t[x].rc,mid+1,r); t[x].sum=t[t[x].lc].sum+t[t[x].rc].sum;}int query(int x,int l,int r){ if(l&lt;=t[x].l&amp;&amp;t[x].r&lt;=r) return t[x].sum; int mid=(t[x].l+t[x].r)/2; int ans=0; if(l&lt;=mid) ans+=query(t[x].lc,l,r); if(mid&lt;r) ans+=query(t[x].rc,l,r); return ans;}void change(int x,int v,int d){ if(t[x].l==t[x].r) { t[x].sum=d; return; } int mid=(t[x].l+t[x].r)/2; if(v&lt;=mid) change(t[x].lc,v,d); if(mid&lt;v) change(t[x].rc,v,d); t[x].sum=t[t[x].lc].sum+t[t[x].rc].sum;}int main(){ int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); root=++tot; build(root,1,n); for(int i=1,k,x,y;i&lt;=m;i++) { scanf(&quot;%d%d%d&quot;,&amp;k,&amp;x,&amp;y); if(k==1) printf(&quot;%d\\n&quot;,query(root,x,y)); if(k==2) change(root,x,y); } } 树状数组 O(nlogn)123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;int a[10001],c[10001];int n;int lowbit(int x){ return x&amp;(-x);}void build(){ for(int i=1;i&lt;=n;i++) { c[i]=a[i]; for(int j=i-1;j&gt;i-lowbit(i);j-=lowbit(j)) c[i]+=c[j]; }}int sum(int x) //求x之前的和 { int sum=0; for(;x;x-=lowbit(x)) sum+=c[x]; return sum;}void change(int x,int y) //把a[x]加y { for(;x&lt;=n;x+=lowbit(x)) c[x]+=y;} tarjan O(n+m)1234567891011121314151617181920212223242526void Tarjan(int i){ int j; dfn[i]=low[i]=++tot; vis[i]=1; stack[++top]=i; for(int e=0;e&lt;to[i].size();e++) { j=to[i][e]; if(!dfn[j]) { Tarjan(j); if(low[j]&lt;low[i]) low[i]=low[j]; } else if(vis[j]&amp;&amp;dfn[j]&lt;low[i]) low[i]=dfn[j]; } if(dfn[i]==low[i]) { do { j=stack[top--]; fa[j]=fa[i]; vis[j]=0; }while(j!=i); }} Lca123456789101112131415161718192021注意dep[1]=1;for(int i=1;i&lt;=log(n)/log(2)+1;i++) for(int j=1;j&lt;=n;j++) fa[j][i]=fa[fa[j][i-1]][i-1], //g[j][i]=max(g[j][i-1],g[fa[j][i-1]][i-1]);int lca(int x,int y){ //int ans=0; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=log(n)/log(2);i&gt;=0;i--) if(dep[fa[x][i]]&gt;=dep[y]) //ans=max(ans,g[x][i]), x=fa[x][i]; if(x==y) return x; for(int i=log(n)/log(2);i&gt;=0;i--) if(fa[x][i]!=fa[y][i]) //ans=max(ans,g[x][i]),ans=max(ans,g[y][i]), x=fa[x][i],y=fa[y][i]; //ans=max(ans,g[x][0]);ans=max(ans,g[y][0]); return fa[x][0];} 矩阵乘法123456789101112131415161718192021222324252627282930313233343536long long multi(long long y,long long cnt) //快速乘 { if (!cnt) return 0; if (cnt==1) return y%m; long long rec=multi(y,cnt/2); rec=(rec+rec)%m; if(cnt%2) rec=(rec+y)%m; return rec;}void cheng(int x){ X[1][1]=0;X[1][2]=0;X[2][1]=0;X[2][2]=0; if(x==0) { for(int i=1;i&lt;=2;i++) for(int j=1;j&lt;=2;j++) for(int k=1;k&lt;=2;k++) X[i][j]=(X[i][j]+multi(A[i][k],N[k][j]))%m; swap(X,N); } else { for(int i=1;i&lt;=2;i++) for(int j=1;j&lt;=2;j++) for(int k=1;k&lt;=2;k++) X[i][j]=(X[i][j]+multi(N[i][k],N[k][j]))%m; swap(X,N); }}void mi(long long n){ if(n==1) return; mi(n/2); cheng(1);//N*N if(n%2) cheng(0);//N*A} 匈牙利算法123456789101112131415161718192021222324252627282930int used[N]; //记录y中节点是否使用 0表示没有访问过，1为访问过int linker[N]; //记录当前与y节点相连的x的节点 int g[N][N]; //记录连接x和y的边，如果i和j之间有边则为1，否则为0int vn,vm; //二分图中x和y中点的数目 bool dfs(int u)//从左边开始找增广路径{ for(int v=0;v&lt;vN;v++)//这个顶点编号从0开始，若要从1开始需要修改 if(g[u][v]&amp;&amp;!used[v]) { used[v]=true; if(linker[v]==-1||dfs(linker[v])) {//找增广路，反向 linker[v]=u; return true; } } return false;//这个不要忘了，经常忘记这句}int hungary(){ int res=0; int u; memset(linker,-1,sizeof(linker)); for(u=0;u&lt;uN;u++) { memset(used,0,sizeof(used)); if(dfs(u)) res++; } return res;} Dinic123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#define LINK(x) for(int e=head[x];e;e=E[e].next)using namespace std;const int N=5000;const int M=10000;const int inf=1e9;struct Edge{int to,rest,next;}E[M];queue&lt;int&gt; Q;int head[N],ds[N];int n,m,S,T,ecnt=1;inline void AddEdge(int x,int y,int r){ ++ecnt;E[ecnt].to=y,E[ecnt].rest=r,E[ecnt].next=head[x];head[x]=ecnt; ++ecnt;E[ecnt].to=x,E[ecnt].rest=0,E[ecnt].next=head[y];head[y]=ecnt;}inline bool BFS(){ //static queue&lt;int&gt; Q; //static 全局变量 for(int i=S;i&lt;=T;i++) ds[i]=-1; Q.push(S);ds[S]=0; while(!Q.empty()) { int x=Q.front(); Q.pop(); LINK(x) if(E[e].rest &amp;&amp; ds[E[e].to]==-1) ds[E[e].to]=ds[x]+1,Q.push(E[e].to); } return ds[T]&gt;-1;}inline int DFS(int x,int flow){ if(x==T) return flow; int a=0,b; LINK(x) if(E[e].rest&amp;&amp;ds[E[e].to]==ds[x]+1) { b=DFS(E[e].to, min(flow-a,E[e].rest)); E[e].rest-=b, E[e^1].rest+=b; a+=b; if(a==flow) return flow; } if(a==0) ds[x]=-1; return a;}inline int dinic(){ int ans=0; while(BFS()) ans+=DFS(S,inf); return ans;}int main(){ scanf(&quot;%d%d%d&quot;,&amp;m,&amp;S,&amp;T); for(int i=1;i&lt;=m;i++) { int u,v,c; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;c); AddEdge(u,v,c); } printf(&quot;%d\\n&quot;,dinic()); return 0;}","link":"/2021/08/04/noip%E6%A8%A1%E6%9D%BF/"},{"title":"Round A 2021 - Kick Start 2021","text":"","link":"/2021/08/05/Round%20A%202021%20-%20Kick%20Start%202021/"},{"title":"永远想念2021年夏天","text":"南京-安吉-杭州-乌镇-上海-苏州 ![IMG_4509](/images/2021年的夏天/IMG_4509.JPG) ![IMG_4655](C:/Blog/blog/public/images/2021年的夏天/IMG_4655.JPG) ![IMG_4739](C:\\Blog\\blog\\public\\images\\2021年的夏天\\IMG_4739.JPG) ![IMG_4751](C:\\Blog\\blog\\public\\images\\2021年的夏天\\IMG_4751.JPG) ![IMG_4752](C:\\Blog\\blog\\public\\images\\2021年的夏天\\IMG_4752.JPG) ![IMG_4754](C:\\Blog\\blog\\public\\images\\2021年的夏天\\IMG_4754.JPG) ![IMG_4755](C:\\Blog\\blog\\public\\images\\2021年的夏天\\IMG_4755.JPG) ![IMG_4756](C:\\Blog\\blog\\public\\images\\2021年的夏天\\IMG_4756.JPG) ![IMG_4767](C:\\Blog\\blog\\public\\images\\2021年的夏天\\IMG_4767.JPG) ![IMG_4786](C:\\Blog\\blog\\public\\images\\2021年的夏天\\IMG_4786.JPG) ![IMG_4823](C:\\Blog\\blog\\public\\images\\2021年的夏天\\IMG_4823.JPG) ![IMG_5023](C:\\Blog\\blog\\public\\images\\2021年的夏天\\IMG_5023.JPG) ![IMG_5035](C:\\Blog\\blog\\public\\images\\2021年的夏天\\IMG_5035.JPG) ![IMG_5036](C:\\Blog\\blog\\public\\images\\2021年的夏天\\IMG_5036.JPG) ![IMG_5048](C:\\Blog\\blog\\public\\images\\2021年的夏天\\IMG_5048.JPG) ![IMG_5057](C:\\Blog\\blog\\public\\images\\2021年的夏天\\IMG_5057.JPG) ![IMG_5060](C:\\Blog\\blog\\public\\images\\2021年的夏天\\IMG_5060.JPG) ![IMG_5065](C:\\Blog\\blog\\public\\images\\2021年的夏天\\IMG_5065.JPG) ![IMG_5105](C:\\Blog\\blog\\public\\images\\2021年的夏天\\IMG_5105.JPG) ![IMG_5107](C:\\Blog\\blog\\public\\images\\2021年的夏天\\IMG_5107.JPG) ![IMG_5132](C:\\Blog\\blog\\public\\images\\2021年的夏天\\IMG_5132.JPG) ![IMG_5138](C:\\Blog\\blog\\public\\images\\2021年的夏天\\IMG_5138.JPG) ![IMG_5140](C:\\Blog\\blog\\public\\images\\2021年的夏天\\IMG_5140.JPG) ![IMG_5162](C:\\Blog\\blog\\public\\images\\2021年的夏天\\IMG_5162.JPG) ![IMG_5255](C:\\Blog\\blog\\public\\images\\2021年的夏天\\IMG_5255.JPG) ![IMG_5265](C:\\Blog\\blog\\public\\images\\2021年的夏天\\IMG_5265.JPG) ![IMG_5274](C:\\Blog\\blog\\public\\images\\2021年的夏天\\IMG_5274.JPG) ![IMG_5314](C:\\Blog\\blog\\public\\images\\2021年的夏天\\IMG_5314.JPG) ![IMG_5335](C:\\Blog\\blog\\public\\images\\2021年的夏天\\IMG_5335.JPG) ![IMG_5342](C:\\Blog\\blog\\public\\images\\2021年的夏天\\IMG_5342.JPG)","link":"/2021/08/19/2021%E5%B9%B4%E5%A4%8F%E5%A4%A9/"}],"tags":[{"name":"Movies","slug":"Movies","link":"/tags/Movies/"},{"name":"Kick Start","slug":"Kick-Start","link":"/tags/Kick-Start/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Coding Competitions","slug":"Coding-Competitions","link":"/tags/Coding-Competitions/"},{"name":"Noip","slug":"Noip","link":"/tags/Noip/"},{"name":"ShotoniPhone","slug":"ShotoniPhone","link":"/tags/ShotoniPhone/"},{"name":"traveling","slug":"traveling","link":"/tags/traveling/"}],"categories":[{"name":"Life","slug":"Life","link":"/categories/Life/"},{"name":"Work","slug":"Work","link":"/categories/Work/"},{"name":"Movies","slug":"Life/Movies","link":"/categories/Life/Movies/"},{"name":"Coding","slug":"Work/Coding","link":"/categories/Work/Coding/"},{"name":"Kick Start","slug":"Work/Coding/Kick-Start","link":"/categories/Work/Coding/Kick-Start/"},{"name":"Photography","slug":"Life/Photography","link":"/categories/Life/Photography/"}]}