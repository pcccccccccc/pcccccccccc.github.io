{"pages":[{"title":"About","text":"Pempè½¯ä»¶å·¥ç¨‹@å—äº¬å¤§å­¦ Coldplay&amp;æ—…è¡Œ&amp;å¹³æƒä¸»ä¹‰ğŸŒˆ wx: pemppeng (è¯·æ³¨æ˜æ¥æ„)","link":"/about/index.html"}],"posts":[{"title":"STLç®€ä»‹","text":"C++ STLæ•™ç¨‹æ‰€æœ‰å¸¸ç”¨æ“ä½œéƒ½åœ¨ä»£ç é‡ŒSTLå¯èƒ½ä¼šå¾ˆæ…¢ï¼Œæ—¶é—´å…è®¸çš„è¯å¯æ›¿ä»£æ“ä½œè¿˜æ˜¯æ‰‹å†™å¥½å»ºè®®å¯¹æ¯ä¸€ç§éƒ½ç›²æ•²2~3éä»£ç ï¼Œä¸è¦çœ¼é«˜æ‰‹ä½ Vector1234567891011121314#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;//ï¼ï¼ï¼å¤´æ–‡ä»¶using namespace std;vector&lt;int&gt; a[100];int main(){ for(int i=1;i&lt;=200;i++) a[1].push_back(i);//æ’å…¥ a[1].pop_back();//å¼¹å‡º cout&lt;&lt;a[1].size()&lt;&lt;endl;//å¤§å° for(int i=0;i&lt;199;i++) cout&lt;&lt;a[1][i]&lt;&lt;endl; } MapMapæ˜¯c++çš„ä¸€ä¸ªæ ‡å‡†å®¹å™¨ï¼ŒæŒ‰å­—é¢æ„æ€å°±æ˜¯åœ°å›¾çš„æ„æ€å³ç»™ä½ ä¸€ä¸ªå…ƒç´ ï¼Œæ ¹æ®â€œåœ°å›¾â€æ‰¾åˆ°è¿™ä¸ªå…ƒç´ å¯¹åº”çš„å…ƒç´  1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 /*å¤´æ–‡ä»¶&lt;map&gt;*/#include &lt;map&gt;#include &lt;iostream&gt;using namespace std;int main(){ map&lt;string,int&gt; a; cout&lt;&lt;&quot;æ’å…¥:&quot;&lt;&lt;endl; a[&quot;April&quot;]=112;//æ’å…¥ cout&lt;&lt;a[&quot;April&quot;]&lt;&lt;endl; cout&lt;&lt;endl; cout&lt;&lt;&quot;æŸ¥è¯¢:&quot;&lt;&lt;endl; map&lt;string,int&gt;::iterator pc;//æŸ¥è¯¢ä¸€ä¸ªå…ƒç´ æ˜¯å¦åœ¨mapé‡Œ pc=a.find(&quot;April&quot;); if(pc==a.end()) cout&lt;&lt;&quot;Not Find&quot;&lt;&lt;endl;//å¦‚æœæ‰¾ä¸åˆ°ä¼šè‡ªåŠ¨è¿”å›â€œæŒ‡å‘mapå°¾éƒ¨çš„è¿­ä»£å™¨â€ else cout&lt;&lt;pc-&gt;second&lt;&lt;endl;//è¾“å‡º&quot;April&quot;å¯¹åº”çš„é”®å€¼ cout&lt;&lt;endl; cout&lt;&lt;&quot;éå†&quot;&lt;&lt;endl; a[&quot;June&quot;]=1;//éå† a[&quot;July&quot;]=2; map&lt;string,int&gt;::iterator i; for(i=a.begin(); i!=a.end(); i++)//ä¸èƒ½ç­‰äºa.end() { cout&lt;&lt;i-&gt;second&lt;&lt;endl; } cout&lt;&lt;endl; cout&lt;&lt;&quot;åˆ¤æ–­mapæ˜¯å¦æ˜¯ç©ºé›†&quot;&lt;&lt;endl; cout&lt;&lt;a.empty()&lt;&lt;endl;//åˆ¤æ–­mapæ˜¯å¦æ˜¯ç©ºé›† cout&lt;&lt;endl; cout&lt;&lt;&quot;äº¤æ¢ä¸¤ä¸ªmapçš„å…ƒç´  &quot;&lt;&lt;endl; map&lt;int ,int&gt; b;//äº¤æ¢ä¸¤ä¸ªmapçš„å…ƒç´  map&lt;int ,int&gt; c; c[1]=1; c[2]=2; b[1]=1000; swap(b,c); map&lt;int,int&gt; ::iterator j; for(j=b.begin();j!=b.end();j++) { cout&lt;&lt;j-&gt;second&lt;&lt;endl; } for(j=c.begin();j!=c.end();j++) { cout&lt;&lt;j-&gt;second&lt;&lt;endl; } } mapä¸­ swapçš„ç”¨æ³•ï¼š Mapä¸­çš„swapä¸æ˜¯ä¸€ä¸ªå®¹å™¨ä¸­çš„å…ƒç´ äº¤æ¢ï¼Œè€Œæ˜¯ä¸¤ä¸ªå®¹å™¨äº¤æ¢ï¼› Mapä¸­çš„å…ƒç´ æ˜¯è‡ªåŠ¨æŒ‰keyå‡åºæ’åº 123456789101112131415161718192021222324252627 #include &lt;map&gt; #include &lt;iostream&gt; using namespace std; int main( ) { map &lt;int, int&gt; m1; map &lt;int, int&gt;::iterator m1_Iter; m1[1]=20; m1[4]=40; m1[3]=60; m1[2]=50; m1[6]=40; m1[7]=30; cout &lt;&lt; &quot;The original map m1 is:&quot;&lt;&lt;endl; for ( m1_Iter = m1.begin( ); m1_Iter != m1.end( ); m1_Iter++ ) cout &lt;&lt; m1_Iter-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;m1_Iter-&gt;second&lt;&lt;endl;}/*The original map m1 is: 1 20 2 50 3 60 4 40 6 40 7 30*/ mapçš„åŸºæœ¬æ“ä½œå‡½æ•°ï¼š 12345678910111213141516171819begin() è¿”å›æŒ‡å‘mapå¤´éƒ¨çš„è¿­ä»£å™¨clear(ï¼‰ åˆ é™¤æ‰€æœ‰å…ƒç´ count() è¿”å›æŒ‡å®šå…ƒç´ å‡ºç°çš„æ¬¡æ•°empty() å¦‚æœmapä¸ºç©ºåˆ™è¿”å›trueend() è¿”å›æŒ‡å‘mapæœ«å°¾çš„è¿­ä»£å™¨*equal_range() è¿”å›ç‰¹æ®Šæ¡ç›®çš„è¿­ä»£å™¨å¯¹erase() åˆ é™¤ä¸€ä¸ªå…ƒç´ find() æŸ¥æ‰¾ä¸€ä¸ªå…ƒç´ get_allocator() è¿”å›mapçš„é…ç½®å™¨insert() æ’å…¥å…ƒç´ key_comp() è¿”å›æ¯”è¾ƒå…ƒç´ keyçš„å‡½æ•°lower_bound() è¿”å›é”®å€¼&gt;=ç»™å®šå…ƒç´ çš„ç¬¬ä¸€ä¸ªä½ç½®max_size() è¿”å›å¯ä»¥å®¹çº³çš„æœ€å¤§å…ƒç´ ä¸ªæ•°rbegin() è¿”å›ä¸€ä¸ªæŒ‡å‘mapå°¾éƒ¨çš„é€†å‘è¿­ä»£å™¨rend() è¿”å›ä¸€ä¸ªæŒ‡å‘mapå¤´éƒ¨çš„é€†å‘è¿­ä»£å™¨size() è¿”å›mapä¸­å…ƒç´ çš„ä¸ªæ•°swap() äº¤æ¢ä¸¤ä¸ªmapupper_bound() è¿”å›é”®å€¼&gt;ç»™å®šå…ƒç´ çš„ç¬¬ä¸€ä¸ªä½ç½®value_comp() è¿”å›æ¯”è¾ƒå…ƒç´ valueçš„å‡½æ•° Set setä½œä¸ºä¸€ä¸ªå®¹å™¨ä¹Ÿæ˜¯ç”¨æ¥å­˜å‚¨åŒä¸€æ•°æ®ç±»å‹çš„æ•°æ®ç±»å‹ï¼Œå¹¶ä¸”èƒ½ä»ä¸€ä¸ªæ•°æ®é›†åˆä¸­å–å‡ºæ•°æ®ï¼Œåœ¨setä¸­æ¯ä¸ªå…ƒç´ çš„å€¼éƒ½å”¯ä¸€ï¼Œè€Œä¸”ç³»ç»Ÿèƒ½æ ¹æ®å…ƒç´ çš„å€¼è‡ªåŠ¨è¿›è¡Œæ’åºã€‚åº”è¯¥æ³¨æ„çš„æ˜¯setä¸­æ•°å…ƒç´ çš„å€¼ä¸èƒ½ç›´æ¥è¢«æ”¹å˜ã€‚ setä¸­å¸¸ç”¨çš„æ–¹æ³• 1234567begin() è¿”å›setå®¹å™¨çš„ç¬¬ä¸€ä¸ªå…ƒç´ end() è¿”å›setå®¹å™¨çš„æœ€åä¸€ä¸ªå…ƒç´ clear() åˆ é™¤setå®¹å™¨ä¸­çš„æ‰€æœ‰çš„å…ƒç´ empty() åˆ¤æ–­setå®¹å™¨æ˜¯å¦ä¸ºç©ºsize() è¿”å›å½“å‰setå®¹å™¨ä¸­çš„å…ƒç´ ä¸ªæ•°count() ç”¨æ¥æŸ¥æ‰¾setä¸­æŸä¸ªæŸä¸ªé”®å€¼å‡ºç°çš„æ¬¡æ•°ã€‚è¿™ä¸ªå‡½æ•°åœ¨setå¹¶ä¸æ˜¯å¾ˆå®ç”¨ï¼Œå› ä¸ºä¸€ä¸ªé”®å€¼åœ¨setåªå¯èƒ½å‡ºç°0æˆ–1æ¬¡ï¼Œè¿™æ ·å°±å˜æˆäº†åˆ¤æ–­æŸä¸€é”®å€¼æ˜¯å¦åœ¨setå‡ºç°è¿‡äº†ã€‚find() ï¼Œè¿”å›ç»™å®šå€¼å€¼å¾—å®šä½å™¨ï¼Œå¦‚æœæ²¡æ‰¾åˆ°åˆ™è¿”å›end()ã€‚ 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int main(){ set&lt;int&gt; s; s.insert(1); s.insert(2); s.insert(3); s.insert(1); cout&lt;&lt;&quot;set çš„ size å€¼ä¸º ï¼š&quot;&lt;&lt;s.size()&lt;&lt;endl; cout&lt;&lt;&quot;set çš„ maxsizeçš„å€¼ä¸º ï¼š&quot;&lt;&lt;s.max_size()&lt;&lt;endl; cout&lt;&lt;&quot;set ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯ ï¼š&quot;&lt;&lt;*s.begin()&lt;&lt;endl; cout&lt;&lt;&quot;set ä¸­çš„æœ€åä¸€ä¸ªå…ƒç´ æ˜¯:&quot;&lt;&lt;*s.end()&lt;&lt;endl; s.clear(); if(s.empty()) { cout&lt;&lt;&quot;set ä¸ºç©º ï¼ï¼ï¼&quot;&lt;&lt;endl; } cout&lt;&lt;&quot;set çš„ size å€¼ä¸º ï¼š&quot;&lt;&lt;s.size()&lt;&lt;endl; cout&lt;&lt;&quot;set çš„ maxsizeçš„å€¼ä¸º ï¼š&quot;&lt;&lt;s.max_size()&lt;&lt;endl; return 0;} lower_bound(key_value) ï¼Œè¿”å›ç¬¬ä¸€ä¸ªå¤§äºç­‰äºkey_valueçš„å®šä½å™¨ upper_bound(key_value)ï¼Œè¿”å›æœ€åä¸€ä¸ªå¤§äºç­‰äºkey_valueçš„å®šä½å™¨ 12345678910111213141516#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int main(){ set&lt;int&gt; s; s.insert(1); s.insert(3); s.insert(4); cout&lt;&lt;*s.lower_bound(2)&lt;&lt;endl; cout&lt;&lt;*s.lower_bound(3)&lt;&lt;endl; cout&lt;&lt;*s.upper_bound(3)&lt;&lt;endl; return 0;} useful link about set Queueæ™®é€šé˜Ÿåˆ—å¤§å®¶éƒ½ä¼šå†™å§ æˆ‘ä»¬æ¥çœ‹çœ‹å¦‚ä½•ç”¨queueæ¥å®ç°å †çš„åŠŸèƒ½ 1234567891011121314151617//å°æ ¹å † #include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q;//é»˜è®¤æ˜¯å¤§æ ¹å †ï¼Œå°æ ¹å †éœ€è¦è‡ªå·±åŠ greater&lt;int&gt;int main(){ q.push(1); q.push(2); q.push(3); while(q.size()) { cout&lt;&lt;q.top()&lt;&lt;endl; q.pop(); }} 1234567891011121314151617//å¤§æ ¹å † #include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;priority_queue&lt;int&gt;q;int main(){ q.push(1); q.push(2); q.push(3); while(q.size()) { cout&lt;&lt;q.top()&lt;&lt;endl; q.pop(); }} Bitsetbitsetå¯ä»¥çœ‹ä½œboolæ•°ç»„ï¼Œä½†ä¼˜åŒ–äº†ç©ºé—´å¤æ‚åº¦å’Œæ—¶é—´å¤æ‚åº¦ï¼Œå¹¶ä¸”å¯ä»¥åƒæ•´å‹ä¸€æ ·æŒ‰ä½ä¸æˆ–ã€‚ 123456789101112131415161718#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;bitset&gt;using namespace std;bitset&lt;10&gt; a;//&lt;&gt;ä¸­é—´æ˜¯é•¿åº¦ï¼ï¼ï¼bitset&lt;10&gt; b;int main(){ a.set();//å…¨éƒ¨ç½®ä¸º1 cout&lt;&lt;a&lt;&lt;endl; a.reset();//å…¨éƒ¨ç½®ä¸º0 a[1]=1;//å¯ä»¥ç›´æ¥æŠŠå®ƒå½“ä½œä¸€ä¸ªæ•°æ¥è¿›è¡ŒäºŒè¿›åˆ¶æ“ä½œ a=a|b; cout&lt;&lt;a.count()&lt;&lt;endl; //è¾“å‡ºbitseté‡Œæœ‰å¤šå°‘ä¸ª1 cout&lt;&lt;a&lt;&lt;endl; a.flip();//å°†bitseté‡Œçš„å…ƒç´ ç¿»è½¬ä¸€ä¸‹ cout&lt;&lt;a;} &lt;&gt;ä¸­é—´æ˜¯é•¿åº¦ï¼ï¼ï¼ bitsetç©ºé—´å ç”¨ååˆ†å°ï¼Œè¿è¡Œé€Ÿåº¦ä¹Ÿå¾ˆå¿«ï¼ï¼å¥‡æŠ€æ·«å·§ å¸¸ç”¨çš„æˆå‘˜å‡½æ•°ï¼š 12345678910111213141516b.any() bä¸­æ˜¯å¦å­˜åœ¨ç½®ä¸º1çš„äºŒè¿›åˆ¶ä½ï¼Ÿb.none() bå­˜åœ¨ç½®ä¸º1çš„äºŒè¿›åˆ¶ä½å—ï¼Ÿb.count() bä¸­ç½®ä¸º1çš„äºŒè¿›åˆ¶ä½çš„ä¸ªæ•°b.size() bä¸­äºŒè¿›åˆ¶ä½æ•°çš„ä¸ªæ•°b[pos] è®¿é—®bä¸­åœ¨poså¤„äºŒè¿›åˆ¶ä½b.test(pos) bä¸­åœ¨poså¤„çš„äºŒè¿›åˆ¶ä½ç½®ä¸º1ä¹ˆï¼Ÿb.set() æŠŠbä¸­æ‰€æœ‰äºŒè¿›åˆ¶ä½éƒ½ç½®ä¸º1b.set(pos) æŠŠbä¸­åœ¨poså¤„çš„äºŒè¿›åˆ¶ä½ç½®ä¸º1b.reset( ) æŠŠbä¸­æ‰€æœ‰äºŒè¿›åˆ¶ä½éƒ½ç½®ä¸º0b.reset( pos ) æŠŠbä¸­åœ¨poså¤„çš„äºŒè¿›åˆ¶ä½ç½®ç½®ä¸º0b.flip( ) æŠŠbä¸­æ‰€æœ‰äºŒè¿›åˆ¶ä½é€ä½å–åb.flip( pos ) æŠŠbä¸­åœ¨poså¤„çš„äºŒè¿›åˆ¶ä½å–åb.to_ulong( ) æŠŠbä¸­åŒæ ·çš„äºŒè¿›åˆ¶ä½è¿”å›ä¸€ä¸ªunsignedb._Find_next(pos) è¿”å›bitsetåœ¨ä½ç½®posä¹‹åç¬¬ä¸€ä¸ª1çš„ä½ç½® useful link about Bitset lower_bound&amp;upper_bound å‡½æ•°lower_bound()åœ¨firstå’Œlastä¸­çš„å‰é—­åå¼€åŒºé—´è¿›è¡ŒäºŒåˆ†æŸ¥æ‰¾ï¼Œè¿”å›å¤§äºæˆ–ç­‰äº**valçš„ç¬¬ä¸€ä¸ªå…ƒç´ ä½ç½®ã€‚å¦‚æœæ‰€æœ‰å…ƒç´ éƒ½å°äºvalï¼Œåˆ™è¿”å›lastçš„ä½ç½®ç”¨æ³•ï¼š int t=lower_bound(a+l,a+r,m)-a å‡½æ•°upper_bound()åœ¨firstå’Œlastä¸­çš„å‰é—­åå¼€åŒºé—´è¿›è¡ŒäºŒåˆ†æŸ¥æ‰¾ï¼Œè¿”å›å¤§äºvalçš„ç¬¬ä¸€ä¸ªå…ƒç´ ä½ç½®ã€‚å¦‚æœæ‰€æœ‰å…ƒç´ éƒ½å°äºvalï¼Œåˆ™è¿”å›lastçš„ä½ç½®å¤æ‚åº¦O(logn)","link":"/2021/07/30/STL/"},{"title":"å‰§&amp;ç”µå½±","text":"åœ¨çœ‹ Girl From Nowhere S1 Stranger Things S1 Dark S1 çœ‹è¿‡ Why Women Kill S2 ğŸ‘ğŸ‘ğŸ‘ Girl From Nowhere S2 ğŸ‘ğŸ‘ğŸ‘ Killing Eve S1-3 ğŸ‘ğŸ‘ğŸ‘ğŸ‘ğŸ‘ A Quiet Place: Part 2 ğŸ‘ğŸ‘ğŸ‘ğŸ‘ F9: The Fast Saga ğŸ¤®ğŸ¤®ğŸ¤® El inocente ğŸ‘ğŸ‘ğŸ‘ğŸ‘ æˆ‘çš„å§å§ ğŸ‘ğŸ‘ğŸ‘ Godzilla vs Kong ğŸ‘ğŸ‘ğŸ‘ Persischstunden ğŸ‘ğŸ‘ğŸ‘ğŸ‘ The End of the Fucking World S1-2 ğŸ‘ğŸ‘ğŸ‘ğŸ‘ğŸ‘ Behind Her Eyes ğŸ‘ğŸ‘ğŸ‘ğŸ‘ WandaVision ğŸ‘ğŸ‘ğŸ‘ğŸ‘ğŸ‘ Nomadland ğŸ‘ğŸ‘ğŸ‘ğŸ‘ The Queenâ€™s Gambit ğŸ‘ğŸ‘ğŸ‘ğŸ‘ğŸ‘ The Boys in the Band ğŸ‘ğŸ‘ğŸ‘ğŸ‘ Sense8 ğŸ‘ğŸ‘ğŸ‘ğŸ‘ğŸ‘ Love, Victor ğŸ‘ğŸ‘ğŸ‘ğŸ‘ Chernobyl ğŸ‘ğŸ‘ğŸ‘ğŸ‘ Call Me By Your Name ğŸ‘ğŸ‘ğŸ‘ğŸ‘ğŸ‘","link":"/2021/08/04/%E6%9C%80%E8%BF%91%E5%9C%A8%E7%9C%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E5%89%A7/"},{"title":"noipæ¨¡æ¿","text":"noipæ—¶æœŸçš„ä¸€äº›æ¿å­ æ•°æ®ç»“æ„çº¿æ®µæ ‘1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int N=1e5;int n,m,tot,root;struct Tree{ int l,r,ls,rs,sum,max,tag;}t[N*2];void push_up(int x){ int L=t[x].ls,R=t[x].rs; t[x].sum=t[L].sum+t[R].sum; t[x].max=max(t[L].max,t[R].max);}void push_down(int x){ if(t[x].tag) { int L=t[x].ls,R=t[x].rs,T=t[x].tag;t[x].tag=0; t[L].sum+=(t[L].r-t[L].l+1)*T;t[L].max+=T;t[L].tag+=T; t[R].sum+=(t[R].r-t[R].l+1)*T;t[R].max+=T;t[R].tag+=T; }}void Build(int &amp;x,int L,int R){ x=++tot; t[x].l=L;t[x].r=R; if(L==R) {scanf(&quot;%d&quot;,&amp;t[x].sum);t[x].max=t[x].sum;return;} int mid=(L+R)&gt;&gt;1; Build(t[x].ls,L,mid); Build(t[x].rs,mid+1,R); push_up(x);}void Change(int x,int pos,int key){ if(t[x].l==t[x].r) {t[x].sum=t[x].max=key;return;} push_down(x); int mid=(t[x].l+t[x].r)&gt;&gt;1; if(pos&lt;=mid) Change(t[x].ls,pos,key); else Change(t[x].rs,pos,key); push_up(x);}void Add(int x,int L,int R,int key){ if(L&lt;=t[x].l&amp;&amp;R&gt;=t[x].r) {t[x].sum+=(t[x].r-t[x].l+1)*key;t[x].max+=key;t[x].tag+=key;return;} push_down(x); int mid=(t[x].l+t[x].r)&gt;&gt;1; if(L&lt;=mid) Add(t[x].ls,L,R,key); if(mid&lt;R) Add(t[x].rs,L,R,key); push_up(x);}int Sum(int x,int L,int R){ if(L&lt;=t[x].l&amp;&amp;R&gt;=t[x].r) return t[x].sum; push_down(x); int mid=(t[x].l+t[x].r)&gt;&gt;1,sum=0; if(L&lt;=mid) sum+=Sum(t[x].ls,L,R); if(R&gt;mid) sum+=Sum(t[x].rs,L,R); return sum;}int Max(int x,int L,int R){ if(L&lt;=t[x].l&amp;&amp;R&gt;=t[x].r) return t[x].max; push_down(x); int mid=(t[x].l+t[x].r)&gt;&gt;1,mx=0; if(L&lt;=mid) mx=max(mx,Max(t[x].ls,L,R)); if(R&gt;mid) mx=max(mx,Max(t[x].rs,L,R)); return mx;}int main(){ freopen(&quot;tree.in&quot;,&quot;r&quot;,stdin); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); Build(root,1,n); for(int i=1,t,x,y,z;i&lt;=m;i++) { scanf(&quot;%d&quot;,&amp;t); if(t==1) scanf(&quot;%d%d&quot;,&amp;x,&amp;y),Change(1,x,y); else if(t==2) scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z),Add(1,x,y,z); else if(t==3) scanf(&quot;%d%d&quot;,&amp;x,&amp;y),printf(&quot;%d\\n&quot;,Sum(1,x,y)); else scanf(&quot;%d%d&quot;,&amp;x,&amp;y),printf(&quot;%d\\n&quot;,Max(1,x,y)); }} æ ‘é“¾å‰–åˆ†123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;iostream&gt;#include&lt;cstdio&gt;const int N=30010;int n,Q,ans,tot,dep[N],fa[N],size[N],son[N],top[N],pos[N],a[N];int head[N],next[N*2],to[N*2];struct node{ int l,r,ls,rs,max,sum;}t[N*2];void Dfs(int x){ dep[x]=dep[fa[x]]+1;size[x]=1; for(int e=head[x],y=to[e];e;y=to[e=next[e]]) if(y!=fa[x]) { fa[y]=x;Dfs(y); size[x]+=size[y]; if(size[y]&gt;size[son[x]]) son[x]=y; }}void Dfs(int x,int f){ pos[x]=++tot;top[x]=f; if(son[x]) Dfs(son[x],f); for(int e=head[x],y=to[e];e;y=to[e=next[e]]) if(y!=fa[x]&amp;&amp;y!=son[x]) Dfs(y,y);}void push_up(int x){ int L=t[x].ls,R=t[x].rs; t[x].sum=t[L].sum+t[R].sum; t[x].max=std::max(t[L].max,t[R].max);}void Build(int x,int l,int r){ t[x].l=l;t[x].r=r; if(l==r) { t[x].max=t[x].sum=a[l];return; } int mid=(l+r)&gt;&gt;1; Build(t[x].ls=++tot,l,mid); Build(t[x].rs=++tot,mid+1,r); push_up(x);}void Change(int x,int num,int key){ if(t[x].l==t[x].r) { t[x].max=t[x].sum=key;return; } int mid=(t[x].l+t[x].r)&gt;&gt;1; if(num&lt;=mid) Change(t[x].ls,num,key); else Change(t[x].rs,num,key); push_up(x);}int Max(int x,int L,int R){ if(L&lt;=t[x].l&amp;&amp;R&gt;=t[x].r) return t[x].max; int mid=(t[x].l+t[x].r)&gt;&gt;1,num=-30001; if(L&lt;=mid) num=std::max(num,Max(t[x].ls,L,R)); if(R&gt;mid) num=std::max(num,Max(t[x].rs,L,R)); return num;}int Sum(int x,int L,int R){ if(L&lt;=t[x].l&amp;&amp;R&gt;=t[x].r) return t[x].sum; int mid=(t[x].l+t[x].r)&gt;&gt;1,num=0; if(L&lt;=mid) num+=Sum(t[x].ls,L,R); if(R&gt;mid) num+=Sum(t[x].rs,L,R); return num;}int GetMax(int x,int y){ for(ans=-30001;top[x]!=top[y];x=fa[top[x]]) { if(dep[top[x]]&lt;dep[top[y]]) std::swap(x,y); ans=std::max(ans,Max(1,pos[top[x]],pos[x])); } if(pos[x]&gt;pos[y]) std::swap(x,y); return std::max(ans,Max(1,pos[x],pos[y]));}int GetSum(int x,int y){ for(ans=0;top[x]!=top[y];x=fa[top[x]]) { if(dep[top[x]]&lt;dep[top[y]]) std::swap(x,y); ans+=Max(1,pos[top[x]],pos[x]); } if(pos[x]&gt;pos[y]) std::swap(x,y); return ans+Max(1,pos[x],pos[y]);}int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1,ecnt=0,x,y;i&lt;n;i++) { scanf(&quot;%d%d&quot;,&amp;x,&amp;y); to[++ecnt]=y;next[ecnt]=head[x];head[x]=ecnt; to[++ecnt]=x;next[ecnt]=head[y];head[y]=ecnt; } Dfs(1);Dfs(1,1); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[pos[i]]); Build(tot=1,1,n); scanf(&quot;%d&quot;,&amp;Q);char s[10]; for(int i=1,x,y;i&lt;=Q;i++) { scanf(&quot;%s%d%d&quot;,s,&amp;x,&amp;y); if(s[0]=='C') Change(1,pos[x],y); else if(s[1]=='M') printf(&quot;%d\\n&quot;,GetMax(x,y)); else printf(&quot;%d\\n&quot;,GetSum(x,y)); }} SBT123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;cstdio&gt;using namespace std;const int N=1e5+5;int tot,root,key[N],size[N],son[N][2];void Rotate(int &amp;x,bool flag) //0-&gt;left_rotate 1-&gt;right_rotate{ int y=son[x][!flag]; son[x][!flag]=son[y][flag]; son[y][flag]=x; size[y]=size[x]; size[x]=size[son[x][0]]+size[son[x][1]]+1; x=y;}void Maintain(int &amp;x,bool flag) //0-&gt;ls 1-&gt; rs{ if(size[son[son[x][flag]][flag]]&gt;size[son[x][!flag]]) Rotate(x,!flag); else if(size[son[son[x][flag]][!flag]]&gt;size[son[x][!flag]]) Rotate(son[x][flag],flag),Rotate(x,!flag); else return; Maintain(son[x][0],0); Maintain(son[x][1],1); Maintain(x,1); Maintain(x,0); }void Insert(int &amp;x,int y){ if(!x) { x=++tot; key[x]=y; size[x]=1; son[x][0]=son[x][1]=0; return; } size[x]++; if(y&lt;=key[x]) Insert(son[x][0],y); else Insert(son[x][1],y); Maintain(x,y&gt;key[x]);}int Delete(int &amp;x,int y){ size[x]--; if((y&lt;key[x]&amp;&amp;!son[x][0])||(y&gt;key[x]&amp;&amp;!son[x][1])) return 0; if(y==key[x]) { int ans=key[x]; if(!son[x][0]||!son[x][1]) x=son[x][0]+son[x][1]; else { int k=son[x][0]; while(son[k][1]) k=son[k][1]; key[x]=Delete(son[x][0],key[k]); } return ans; } if(y&lt;key[x]) return Delete(son[x][0],y); else return Delete(son[x][1],y);}int Find(int x,int y){ if(!x) return 0; if(y==key[x]) return 1; else if(y&lt;key[x]) return Find(son[x][0],y); else return Find(son[x][1],y);}int Rank(int x,int y){ if(!x) return 1; else if(y&lt;=key[x]) return Rank(son[x][0],y); else return size[son[x][0]]+1+Rank(son[x][1],y);}int Kth(int x,int y){ if(y==size[son[x][0]]+1) return key[x]; else if(y&lt;=size[son[x][0]]) return Kth(son[x][0],y); else return Kth(son[x][1],y-size[son[x][0]]-1);}int Pred(int &amp;x,int y){ if(!x) return y; if(y&lt;=key[x]) return Pred(son[x][0],y); else { int ans=Pred(son[x][1],y); if(y==ans) return key[x]; else return ans; }}int Succ(int &amp;x,int y){ if(!x) return y; if(y&gt;=key[x]) return Succ(son[x][1],y); else { int ans=Succ(son[x][0],y); if(y==ans) return key[x]; else return ans; }}void Inorder(int x){ if(x) { Inorder(son[x][0]); printf(&quot;%d &quot;,key[x]); Inorder(son[x][1]); }}int main(){ freopen(&quot;sbt.in&quot;,&quot;r&quot;,stdin); int x,y; while(scanf(&quot;%d%d&quot;,&amp;x,&amp;y)!=EOF) { if(x==1) Insert(root,y); else if(x==2) Delete(root,y); else if(x==3) printf(&quot;%d\\n&quot;,Find(root,y)); else if(x==4) printf(&quot;%d\\n&quot;,Rank(root,y)); else if(x==5) printf(&quot;%d\\n&quot;,Kth(root,y)); else if(x==6) printf(&quot;%d\\n&quot;,Pred(root,y)); else printf(&quot;%d\\n&quot;,Succ(root,y)); //if(x&lt;=2) Inorder(root),printf(&quot;\\n&quot;); }} splay123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;cstdio&gt;const int N=1e5+5;int tot,root,size[N],num[N],key[N],fa[N],son[N][2];void push_up(int x){ size[x]=size[son[x][0]]+size[son[x][1]]+num[x];}void Rotate(int x){ //push_down(fa[x]);push_down(x); int y=fa[x],z=fa[y],t=(son[y][0]==x); if(z) son[z][son[z][1]==y]=x;fa[x]=z; son[y][!t]=son[x][t];fa[son[y][!t]]=y; son[x][t]=y;fa[y]=x; push_up(y);push_up(x);}void Splay(int x,int f){ while(fa[x]!=f) { int y=fa[x],z=fa[y]; if(z!=f) { if(son[z][0]==y^son[y][0]==x) Rotate(x); else Rotate(y); } Rotate(x); } if(!f) root=x;}void Insert(int &amp;x,int v,int f){ if(!x) { x=++tot; son[x][0]=son[x][1]=0; size[x]=num[x]=1; key[x]=v;fa[x]=f; Splay(x,0); return; } if(v==key[x]) { num[x]++;size[x]++; Splay(x,0); return; } Insert(son[x][v&gt;key[x]],v,x); push_up(x);}int Get(int v){ int x=root; while(x&amp;&amp;v!=key[x]) x=son[x][v&gt;key[x]]; return x;}void Delete(int x){ x=Get(x);if(!x) return; Splay(x,0); if(num[x]&gt;1) {num[x]--;size[x]--;return;} if(!son[x][0]||!son[x][1]) root=son[x][0]+son[x][1]; else { int y=son[x][1];while(son[y][0]) y=son[y][0]; Splay(y,x); son[y][0]=son[x][0];fa[son[y][0]]=y; root=y; } fa[root]=0; push_up(root);}int Rank(int v){ Insert(root,v,0); int ans=size[son[root][0]]+1; Delete(v); return ans;}int Kth(int x){ int y=root; while(x&lt;=size[son[y][0]]||x&gt;size[son[y][0]]+num[y]) { if(x&lt;=size[son[y][0]]) y=son[y][0]; else x-=size[son[y][0]]+num[y],y=son[y][1]; } return key[y];}int Pred(int v){ Insert(root,v,0); int x=son[root][0];while(son[x][1]) x=son[x][1]; Delete(v); return key[x];}int Succ(int v){ Insert(root,v,0); int x=son[root][1];while(son[x][0]) x=son[x][0]; Delete(v); return key[x];}void Inorder(int x){ if(son[x][0]) Inorder(son[x][0]); for(int i=1;i&lt;=num[x];i++) printf(&quot;%d &quot;,key[x]); if(son[x][1]) Inorder(son[x][1]);}int main(){ for(int x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y)!=EOF;) { if(x==1) Insert(root,y,0); else if(x==2) Delete(y); else if(x==3) printf(&quot;%d\\n&quot;,Get(y)); else if(x==4) printf(&quot;%d\\n&quot;,Rank(y)); else if(x==5) printf(&quot;%d\\n&quot;,Kth(y)); else if(x==6) printf(&quot;%d\\n&quot;,Pred(y)); else printf(&quot;%d\\n&quot;,Succ(y)); //if(x&lt;=2) Inorder(root),printf(&quot;\\n&quot;); }} LCT1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;#include &lt;cstdio&gt;const int N=1e5;int n,m,fa[N],son[N][2],size[N],key[N],sum[N],max[N],tag[N],rev[N];inline bool isroot(int x){ return son[fa[x]][0]!=x&amp;&amp;son[fa[x]][1]!=x;}inline void Add(int x,int v){ key[x]+=v;sum[x]+=v*size[x];max[x]+=v;tag[x]+=v;}inline void push_up(int x){ size[x]=size[son[x][0]]+size[son[x][1]]+1; sum[x]=sum[son[x][0]]+sum[son[x][1]]+key[x]; max[x]=std::max(std::max(max[son[x][0]],max[son[x][1]]),key[x]);}inline void push_down(int x){ if(rev[x]) rev[x]^=1,rev[son[x][0]]^=1,rev[son[x][1]]^=1,std::swap(son[x][0],son[x][1]); if(tag[x]) Add(son[x][0],tag[x]),Add(son[x][1],tag[x]),tag[x]=0;}inline void Rotate(int x){ push_down(fa[x]);push_down(x); int y=fa[x],z=fa[y],t=(son[y][0]==x); if(!isroot(y)) son[z][son[z][1]==y]=x;fa[x]=z; son[y][!t]=son[x][t];fa[son[y][!t]]=y; son[x][t]=y;fa[y]=x; push_up(y);push_up(x);}inline void Splay(int x){ push_down(x); while(!isroot(x)) { int y=fa[x],z=fa[y]; if(!isroot(y)) { if(son[z][0]==y^son[y][0]==x) Rotate(x); else Rotate(y); } Rotate(x); }}inline void Access(int x) //å°†xåˆ°rootçš„è·¯å¾„å˜æˆå®è·¯å¾„{ for(int y=0;x;y=x,x=fa[x]) Splay(x),son[x][1]=y,push_up(x);}inline void Makeroot(int x) //å°†xå˜ä¸ºroot{ Access(x);Splay(x);rev[x]^=1;}inline void Split(int x,int y) //å°†xåˆ°yçš„è·¯å¾„æ”¾å…¥splayï¼Œxä¸ºæ ¹{ Makeroot(x);Access(y);Splay(x);}inline void Link(int x,int y){ Makeroot(x);fa[x]=y;}inline void Cut(int x,int y){ Split(x,y);son[x][1]=fa[y]=0;}inline int Find(int x) //æ‰¾åˆ°xæ‰€åœ¨æ ‘çš„root{ Access(x);Splay(x);while(son[x][0]) x=son[x][0];return x;}int main(){ max[0]=-0x7fffffff; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1,x;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;x),size[i]=1,Add(i,x),tag[i]=0; for(int i=1,opt,x,y,z;i&lt;=m;i++) { scanf(&quot;%d%d%d&quot;,&amp;opt,&amp;x,&amp;y); if(opt==1) Link(x,y); else if(opt==2) Cut(x,y); else if(opt==3) Splay(x),key[x]=y,push_up(x); //æ›´æ”¹xçš„æƒå€¼ä¸ºy else if(opt==4) Split(x,y),printf(&quot;%d\\n&quot;,max[x]); //æ±‚xåˆ°yè·¯å¾„ä¸Šçš„æœ€å¤§å€¼ else if(opt==5) Split(x,y),printf(&quot;%d\\n&quot;,sum[x]); //æ±‚xåˆ°yè·¯å¾„ä¸Šçš„å’Œ else if(opt==6) printf(&quot;%d\\n&quot;,Find(x)==Find(y)); //åˆ¤æ–­xå’Œyæ˜¯å¦è¿é€š else scanf(&quot;%d&quot;,&amp;z),Split(x,y),Add(x,z); //å°†xåˆ°yè·¯å¾„ä¸ŠåŠ z }} ä¸»å¸­æ ‘123456789101112131415161718192021222324252627282930313233#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;const int N=100005;int n,m,tot,totn,a[N],b[N],root[N],size[N*20],ls[N*20],rs[N*20];void Insert(int l,int r,int x,int &amp;y,int v){ y=++tot; size[y]=size[x]+1; ls[y]=ls[x];rs[y]=rs[x]; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(v&lt;=mid) Insert(l,mid,ls[x],ls[y],v); else Insert(mid+1,r,rs[x],rs[y],v);}int Quary(int l,int r,int x,int y,int v){ if(l==r) return l; int mid=(l+r)&gt;&gt;1,k=size[ls[y]]-size[ls[x]]; if(v&lt;=k) return Quary(l,mid,ls[x],ls[y],v); else return Quary(mid+1,r,rs[x],rs[y],v-k);}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),b[i]=a[i]; sort(b+1,b+n+1); totn=unique(b+1,b+n+1)-b-1; for(int i=1;i&lt;=n;i++) Insert(1,totn,root[i-1],root[i],lower_bound(b+1,b+totn+1,a[i])-b); for(int i=1,x,y,z;i&lt;=m;i++) scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z),printf(&quot;%d\\n&quot;,b[Quary(1,totn,root[x-1],root[y],z)]);} ç½‘ç»œæµDinic12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int N=5005,M=10005;int n,m,S,T,ans,ecnt=1,ds[N],head[N],to[M&lt;&lt;1],rest[M&lt;&lt;1],next[M&lt;&lt;1];queue&lt;int&gt; Q;void Addedge(int x,int y,int z){ to[++ecnt]=y;rest[ecnt]=z;next[ecnt]=head[x];head[x]=ecnt; to[++ecnt]=x;rest[ecnt]=0;next[ecnt]=head[y];head[y]=ecnt;}bool Bfs(){ for(int i=0;i&lt;=T;i++) ds[i]=0; Q.push(S);ds[S]=1; while(!Q.empty()) { int x=Q.front();Q.pop(); for(int e=head[x],y=to[e];e;e=next[e],y=to[e]) if(rest[e]&amp;&amp;!ds[y]) ds[y]=ds[x]+1,Q.push(y); } return ds[T];}int Dfs(int x,int flow){ if(x==T) return flow; int a=0,b; for(int e=head[x],y=to[e];e;e=next[e],y=to[e]) if(rest[e]&amp;&amp;ds[y]==ds[x]+1) { b=Dfs(y,min(flow-a,rest[e])); rest[e]-=b;rest[e^1]+=b;a+=b; if(a==flow) break; } if(!a) ds[x]=0; return a;}int main(){ scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;S,&amp;T); for(int i=1,x,y,z;i&lt;=m;i++) scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z),Addedge(x,y,z); while(Bfs()) ans+=Dfs(S,0x7fffffff); printf(&quot;%d\\n&quot;,ans);} MCF12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int inf=0x3fffffff;const int N=100;const int M=2000;int n,m,S,T,ds[N],pre[N],maxflow,mincost;int ecnt=1,st[N],to[M*2],rest[M*2],cost[M*2],next[M*2];bool used[N];queue&lt;int&gt; Q;void Addedge(int x,int y,int r,int c){ to[++ecnt]=y;rest[ecnt]=r;cost[ecnt]=c;next[ecnt]=st[x];st[x]=ecnt; to[++ecnt]=x;rest[ecnt]=0;cost[ecnt]=-c;next[ecnt]=st[y];st[y]=ecnt;}bool Spfa(){ for(int i=0;i&lt;=T;i++) ds[i]=inf; Q.push(S);ds[S]=0;used[S]=1; while(!Q.empty()) { int x=Q.front();Q.pop();used[x]=0; for(int e=st[x],y=to[e];e;e=next[e],y=to[e]) if(rest[e]&amp;&amp;ds[y]&gt;ds[x]+cost[e]) { ds[y]=ds[x]+cost[e]; pre[y]=e; if(!used[y]) used[y]=1,Q.push(y); } } return ds[T]&lt;inf;}void Update(int flow){ for(int e=pre[T];e;e=pre[to[e^1]]) flow=min(flow,rest[e]); for(int e=pre[T];e;e=pre[to[e^1]]) rest[e]-=flow,rest[e^1]+=flow; maxflow+=flow;mincost+=flow*ds[T];}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); S=1;T=n; for(int i=1,u,v,r,c;i&lt;=n;i++) scanf(&quot;%d%d%d%d&quot;,&amp;u,&amp;v,&amp;r,&amp;c),Addedge(u,v,r,c); while(Spfa()) Update(inf); printf(&quot;Maxflow:%d\\nMinflow:%d\\n&quot;,maxflow,mincost);} å­—ç¬¦ä¸²KMP12345678910111213141516171819202122232425262728#include&lt;cstring&gt;#include&lt;cstdio&gt;int n,m,next[100001];char a[100001],b[100001];void Getnext(){ next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) { while(j!=-1&amp;&amp;b[i]!=b[j]) j=next[j]; next[i+1]=j+1; }}void KMP(){ for(int i=0,j=0;i&lt;n;i++,j++) { while(j!=-1&amp;&amp;a[i]!=b[j]) j=next[j]; if(j==m-1) printf(&quot;%d\\n&quot;,i-j+1); }}int main(){ scanf(&quot;%s%s&quot;,a,b); //a-&gt;long b-&gt;short n=strlen(a);m=strlen(b); Getnext(); KMP();} åç¼€æ•°ç»„123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;const int base=29;int n,sa[10001];char s[10001];unsigned long long ha[10001],power[10001]={1};inline unsigned long long HASH(int l,int r){ return ha[r]-ha[l-1]*power[r-l+1];}inline int LCP(int x,int y){ int l=0,r=std::min(n-x+1,n-y+1),mid; while(l&lt;r) { mid=(l+r+1)&gt;&gt;1; if(HASH(x,x+mid-1)==HASH(y,y+mid-1)) l=mid; else r=mid-1; } return l;}inline bool cmp(int x,int y){ int z=LCP(x,y);return s[x+z]&lt;s[y+z];}int main(){ scanf(&quot;%s&quot;,s+1); n=strlen(s+1); for(int i=1;i&lt;=n;i++) ha[i]=ha[i-1]*base+s[i]-'a'+1,power[i]=power[i-1]*base,sa[i]=i; std::sort(sa+1,sa+n+1,cmp); for(int i=2;i&lt;=n;i++) height[i]=LCP(sa[i-1],sa[i]);}3.3 ACè‡ªåŠ¨æœº#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;const int N=500005;int T,n,tot,end[N],fail[N],son[N][26];char s[N*2];std::queue&lt;int&gt; Q;inline void init(int x){ end[x]=0; for(int i=0;i&lt;26;i++) son[x][i]=0;}inline void Add(){ scanf(&quot;%s&quot;,s); int len=strlen(s),pre=0; for(int i=0;i&lt;len;i++) { if(!son[pre][s[i]-'a']) init(son[pre][s[i]-'a']=++tot); pre=son[pre][s[i]-'a']; } end[pre]++;}inline void Build(){ Q.push(0); while(!Q.empty()) { int x=Q.front();Q.pop(); for(int i=0;i&lt;26;i++) { if(son[x][i]) { Q.push(son[x][i]); fail[son[x][i]]=x?son[fail[x]][i]:0; } else son[x][i]=x?son[fail[x]][i]:0; } }}inline int Calc(){ scanf(&quot;%s&quot;,s); int len=strlen(s),pre=0,ans=0; for(int i=0;i&lt;len;i++) { pre=son[pre][s[i]-'a']; for(int j=pre;j;j=fail[j]) ans+=end[j],end[j]=0; } return ans;}int main(){ scanf(&quot;%d&quot;,&amp;T); while(T--) { init(tot=0); for(scanf(&quot;%d&quot;,&amp;n);n;n--) Add(); Build(); printf(&quot;%d\\n&quot;,Calc()); }} Manacher1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;int n,m,maxpos,maxlen,len[200001];char s[100001],a[200001];int main(){ scanf(&quot;%s&quot;,s); n=strlen(s); for(int i=0;i&lt;n;i++) a[m++]='#',a[m++]=s[i]; a[m++]='#';maxlen=-1; for(int i=0,j;i&lt;m;i++) { j=std::min(len[maxpos*2-i],maxlen-i)*(i&lt;=maxlen); while(i-j&gt;=0&amp;&amp;i+j&lt;=m&amp;&amp;a[i-j]==a[i+j]) j++; len[i]=j-1; if(i+j&gt;maxlen) maxpos=i,maxlen=i+j; } for(int i=0;i&lt;m;i++) printf(&quot;%d &quot;,len[i]);} å›æ–‡æ ‘1234567891011121314151617181920212223242526272829303132333435#include &lt;cstring&gt;#include &lt;cstdio&gt; using namespace std;const int N=1e6;int n,LEN,tot,last,son[N][26],fail[N],len[N],num[N];char s[N];inline int newnode(int l){ len[++tot]=l; return tot;}inline int getnode(int x){ while(s[n-len[x]-1]!=s[n]) x=fail[x]; return x;}inline void Add(int c){ int cnt=getnode(last); if(!son[cnt][c]) { int now=newnode(len[cnt]+2); fail[now]=son[getnode(fail[cnt])][c]; son[cnt][c]=now; } num[last=son[cnt][c]]++;}int main(){ scanf(&quot;%s&quot;,s+1); LEN=strlen(s+1); newnode(-1);fail[0]=1; while(++n&lt;=LEN) Add(s[n]-'a'); for(int i=tot;i&gt;=2;i--) num[fail[i]]+=num[i];} å…¶ä»–STLTarjan12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdio&gt;const int N=1e4+5;const int M=1e5+5;int n,m,dfsnum,tot,top,ecnt,st[N],dfn[N],low[N],pos[N],head[N],to[M],next[M];bool vis[N];inline void Addedge(int x,int y){ to[++ecnt]=y;next[ecnt]=head[x];head[x]=ecnt;}inline void Tarjan(int x){ dfn[x]=low[x]=++dfsnum; vis[x]=1; st[++top]=x; for(int e=head[x],y=to[e];e;y=to[e=next[e]]) if(!dfn[y]) Tarjan(y),low[x]=std::min(low[x],low[y]); else if(vis[y]) low[x]=std::min(low[x],dfn[y]); /*{//Aä¸€ä¸ªå¥‡æ€ªçš„å†™æ³• if(!dfn[y]) Tarjan(y); if(vis[y]) low[x]=std::min(low[y],low[x]); }*/ if(dfn[x]==low[x]) { tot++; for(int y;y!=x;) { y=st[top--]; pos[y]=tot; vis[y]=0; } }}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1,x,y;i&lt;=m;i++) scanf(&quot;%d%d&quot;,&amp;x,&amp;y),Addedge(x,y); for(int i=1;i&lt;=n;i++) if(!dfn[i]) Tarjan(i);} æ•°å­¦exgcd12345678910111213141516171819#include &lt;cstdio&gt;using namespace std;int a,b,c,d,x,y;inline void exgcd(int a,int b,int &amp;d,int &amp;x,int &amp;y){ if(!b) d=a,x=1,y=0; else exgcd(b,a%b,d,y,x),y-=a/b*x;}int main(){ scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); exgcd(a,b,d,x,y); if(!(c%d)) { x*=c/d;y*=c/d;a/=d;b/=d; for(int k=-2;k&lt;=2;k++) printf(&quot;%d %d\\n&quot;,x+k*b,y-k*a); }} æ¬§æ‹‰ç­›æ³•12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;const int N=101;int tot,prime[N],not_p[N],phi[N],d[N],e[N],mu[N];int main(){ not_p[1]=1;d[1]=1;mu[1]=1; for(int i=2;i&lt;N;i++) { if(!not_p[i]) { prime[++tot]=i; phi[i]=i-1; d[i]=2; e[i]=1; mu[i]=-1; } for(int j=1,k=2*i;j&lt;=tot&amp;&amp;k&lt;N;k=prime[++j]*i) { not_p[k]=1; if(i%prime[j]) { phi[k]=phi[i]*phi[prime[j]]; d[k]=d[i]*d[prime[j]]; e[k]=1; mu[k]=-mu[i]; } else { phi[k]=phi[i]*prime[j]; d[k]=d[i]/(e[i]+1)*(e[i]+2); e[k]=e[i]+1; mu[k]=0; break; } } }} çŸ©é˜µä¹˜æ³•12345678910111213141516#include &lt;cstring&gt;#include &lt;cstdio&gt;struct Matrix{ int m[11][11],W,H;};Matrix operator * (const Matrix a,const Matrix b) //é»˜è®¤a.W==b.H{ Matrix c; c.H=a.H;c.W=b.W; memset(c.m,0,sizeof(c.m)); for(int i=1;i&lt;=c.H;i++) for(int j=1;j&lt;=c.W;j++) for(int k=1;k&lt;=a.W;k++) c.m[i][j]+=a.m[i][k]*b.m[k][j]; return c;} é«˜æ–¯æ¶ˆå…ƒ12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdio&gt;const int N=1001;int n,m,line,row,a[N][N+1],sure[N];inline int gcd(int x,int y){ return !y?x:gcd(y,x%y);}inline int Guass(){ for(line=row=1;line&lt;=n&amp;&amp;row&lt;=m;line++,row++) //line-&gt;hang row-&gt;lie { int t=line;while(t&lt;=n&amp;&amp;!a[t][row]) t++; if(t&gt;n) {line--;continue;} if(t!=line) std::swap(a[t],a[line]); for(int i=1;i&lt;=n;i++) if(i!=line&amp;&amp;a[i][row]) { int d=gcd(a[i][row],a[line][row]); int ta=a[line][row]/d,tb=a[i][row]/d; for(int j=line;j&lt;=m+1;j++) a[i][j]=a[i][j]*ta-a[line][j]*tb; } } line--;row--; for(int i=line+1;i&lt;=n;i++) if(a[i][m+1]) return -1; if(line&lt;m) { for(int i=1;i&lt;=m;i++) sure[i]=-1; for(int i=line;i;i--) { int cnt=0,num; for(int j=1;j&lt;=m;j++) if(a[i][j]&amp;&amp;sure[j]==-1) cnt++,num=j; if(cnt==1) sure[num]=a[i][m+1]; } return 1; } return 0;}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m+1;j++) scanf(&quot;%d&quot;,&amp;a[i][j]); Guass();} å‡¸åŒ…123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;const int N=1e5+5;const double eps=1e-6;int n,top;double len,S;struct Point { double x,y; } a[N],b[N];double dis(Point x,Point y){ return sqrt((x.x-y.x)*(x.x-y.x)+(x.y-y.y)*(x.y-y.y));}double Cross(Point x,Point y,Point z){ return (x.x-z.x)*(y.y-z.y)-(x.y-z.y)*(y.x-z.x);}double Cross(Point x,Point y){ return x.x*y.y-x.y*y.x;}bool cmp(const Point &amp;x,const Point &amp;y){ double t=Cross(x,y,a[1]);return abs(t)&gt;eps?t&gt;0:dis(a[1],x)&lt;dis(a[1],y);}inline void Graham(){ int t=1; for(int i=2;i&lt;=n;i++) if(a[i].x&lt;a[t].x||(a[i].x==a[t].x&amp;&amp;a[i].y&lt;a[t].y)) t=i; if(t!=1) std::swap(a[t],a[1]); std::sort(a+2,a+n+1,cmp); for(int i=1;i&lt;=n;i++) { while(top&gt;1&amp;&amp;Cross(a[i],b[top],b[top-1])&gt;=0) top--; b[++top]=a[i]; } b[top+1]=b[1];}int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%lf%lf&quot;,&amp;a[i].x,&amp;a[i].y); Graham(); for(int i=1;i&lt;=top;i++) len+=dis(b[i],b[i+1]); printf(&quot;L: %.8lf\\n&quot;,len); for(int i=1;i&lt;=top;i++) S+=Cross(b[i],b[i+1]); printf(&quot;S: %.8lf\\n&quot;,S/2);} æ±‚è´¨å› å­12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;inline int power(int a,int b,int P){ int c=1; for(;b;b&gt;&gt;=1,a=(long long)a*a%P) if(b&amp;1) c=(long long)c*a%P; return c;}inline bool Prime(int base,int x){ if(base==x) return 1; for(int i=x-1;;i&gt;&gt;=1) { int y=power(base,i,x); if(y==x-1) return 1; if(y!=1) return 0; if(i&amp;1) return 1; }}inline bool Miller_Rabin(int x){ if(x==2) return 1; else if(x&lt;2||!(x&amp;1)) return 0; for(int i=1;i&lt;=10;i++) if(!Prime(rand()%(x-1)+1,x)) return 0; return 1;} inline int gcd(int x,int y){ return !y?x:gcd(y,x%y);}inline int Pollard_rho(int n,int a){ for(int i=1,k=1,x=rand()%n,y=x;;i++) { x=((long long)x*x%n+a)%n; int d=gcd(abs(y-x),n); if(d&gt;1&amp;&amp;d&lt;n) return d; if(x==y) return n; if(i==k) y=x,k&lt;&lt;=1; }}inline void findfac(int n){ if(Miller_Rabin(n)) { printf(&quot;%d &quot;,n);return; } int p=n; while(p&gt;=n) p=Pollard_rho(p,rand()%(n-1)+1); findfac(p);findfac(n/p);}int main(){ std::srand(time(NULL)); int n; while(scanf(&quot;%d&quot;,&amp;n)) findfac(n),printf(&quot;\\n&quot;);} å¸¸è§ç®—æ³•è¯»å…¥ä¼˜åŒ–1234567int read(){ int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();} return x*f;} å¿«é€Ÿå¹‚1234567int power(int a,int b,int P){ int re=1; for(;b;b&gt;&gt;=1,a=(long long)a*a%P) if(b&amp;1) re=(long long)re*a%P; return re;} ç­›æ³• O(n)prime ç´ æ•°phi Ï† ä¸å¤§äºxä¸”ä¸xäº’è´¨çš„æ•°çš„ä¸ªæ•°d xçš„æ­£çº¦æ•°çš„ä¸ªæ•°e xçš„æœ€å°è´¨å› æ•°çš„ä¸ªæ•° 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const int N = 100 + 1;int prime[N], e[N], d[N], tot, phi[N];bool not_p[N];inline void pre(){ not_p[1] = 1; d[1] = 1; for(int i = 2; i &lt; N; ++i) { if(!not_p[i]) { prime[++tot] = i; e[i] = 1; d[i] = 2; phi[i] = i - 1; } for(int j = 1; j &lt;= tot; ++j) { int k = prime[j] * i; if(k &gt; N) break; not_p[k] = 1; if(i % prime[j]) { d[k] = d[i] * d[prime[j]]; e[k] = 1; phi[k] = phi[i] * phi[prime[j]]; } else{ d[k] = d[i] / (e[i] + 1) * (e[i] + 2); e[k] = e[i] + 1; phi[k] = phi[i] * prime[j]; break; } } }}//å•ç‹¬æ±‚æ¬§æ‹‰å‡½æ•° LL Phi(LL x){ LL i,re=x; for(i=2;i*i&lt;=x;i++) if(x%i==0) { re/=i; re*=i-1; while(x%i==0) x/=i; } if(x!=1) re/=x,re*=(x-1); return re;} ged&amp;&amp;exgcd O(logn)å‡½æ•°æ±‚å‡ºax+by=gcd(a,b)çš„å…¶ä¸­ä¸€ç»„è§£ax+by=cçš„è§£å°±æ˜¯xÃ—c/d,yÃ—c/dï¼ˆå½“ç„¶å¦‚æœc%d!=0çš„è¯ï¼Œæ— æ•´æ•°è§£ï¼‰âˆ´pÃ—a+qÃ—b=cçš„å…¶ä»–æ•´æ•°è§£æ»¡è¶³ï¼šxx = x+b/dÃ—tyy = y-a/dÃ—t (tâˆˆZ) gcd1234int gcd(int a,int b){ return b==0?a:gcd(b,a%b);} exgcd12345int exgcd(int a,int b,int &amp;d,int &amp;x,int &amp;y){ if(!b) { d=a; x=1; y=0; } else { exgcd(b,a%b,d,y,x); y-=x*(a/b); }} kmp O(n)M çŸ­ä¸²ï¼Œé•¿åº¦ä¸ºmT é•¿ä¸²ï¼Œé•¿åº¦ä¸ºn 123456789101112131415161718int KMP(){ for(int i=0,j=0;i&lt;n;i++,j++) { while(j!=-1&amp;&amp;W[j]!=T[i]) j=next[j]; if(j==m-1) return i-m+2; }}void getNext(){ next[0]=-1; for(int i=1;i&lt;m;i++) for(int j=next[i];j&gt;=0;j=next[j]) if(W[j]==W[i]) { next[i+1]=j+1;break; }} èƒŒåŒ…é—®é¢˜01èƒŒåŒ…123456789for(int i=1;i&lt;=n;i++) for(int v=0;v&lt;=m;v++) { if(v-w[i]&gt;=0) f[i][v]=max(f[i-1][v],f[i-1][v-w[i]]+c[i]); else f[i][v]=f[i-1][v]; }for(int i=1;i&lt;=n;i++) for(int v=m;v&gt;=w[i];v--) f[v]=max(f[v],f[v-w[i]]+c[i]); å®Œå…¨èƒŒåŒ…ä¼˜åŒ–ï¼šæ‹†æˆw[i]*2^k , c[i]*2^k çš„è‹¥å¹²ä»¶ï¼ˆå…¶ä¸­w[i]*2^k&lt;Vï¼‰ 123456789for(int i=1;i&lt;=n;i++) for(int v=0;v&lt;=m;v++) { if(v-w[i]&gt;=0) f[i][v]=max(f[i-1][v],f[i][v-w[i]]+c[i]); else f[i][v]=f[i-1][v]; } for(int i=1;i&lt;=n;i++) for(int v=w[i];v&lt;=m;v++) f[v]=max(f[v],f[v-w[i]]+c[i]); å¤šé‡èƒŒåŒ…ä¼˜åŒ–ï¼šæ‹†æˆ1,2,4,â€¦, 2^(k-1) , n[i]-2^k+1 ï¼ˆå…¶ä¸­kä¸ºæ»¡è¶³n[i]-x^k+1&gt;0çš„æœ€å¤§æ•´æ•°) 1234567891011121314for(int i=1;i&lt;=n;i++) for(int v=0;v&lt;=m;v++) for(int k=0;k&lt;=num[i];k++) { f[i][v]=max(f[i][v],f[i-1][v]); if(v-k*w[i]&gt;=0) f[i][v]=max(f[i][v],f[i-1][v-k*w[i]]+k*c[i]); }for(int i=1;i&lt;=n;i++) for(int v=m;v&gt;=0;v--) for(int k=0;k&lt;=num[i];k++) { if(v-k*w[i]&lt;0) break; f[v]=max(f[v],f[v-k*w[i]]+k*c[i]); } ç¦»æ•£åŒ–12345678int main(){ map&lt;int,int&gt;m; for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,b[i]); sort(b+1,b+n+1); b[0]=unique(b+1,b+n+1)-(b+1); for(int j=1;j&lt;=b[0];j++) m[b[j]]=j;} å¹¶æŸ¥é›†12345678int father(int x){ return fa[x]==x?x:fa[x]=father(fa[x]);}int unionn(int x,int y){ fa[father(x)]=father(y);} æœ€çŸ­è·¯SPFA O(kE)123456789101112131415161718memset(ds,0x7f,sizeof(ds));ds[S]=0; vis[S]=1; q.push(S);while(!q.empty()){ int x=q.front(); q.pop(); vis[x]=0; for(int i=0;i&lt;to[x].size();i++) { int y=to[x][i],c=cost[x][i]; if(ds[y]&gt;ds[x]+c) { ds[y]=ds[x]+c; if(!vis[y]) { vis[y]=1; q.push(y); } } }} Dijkstra O(n*logn)1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int N=10005;const int M=100005;const int inf=0x7fffffff;int st[N],next[2*M],ed[2*M],cost[2*M],tot,ds[N],n,m;inline void add(int x,int y,int z){ next[++tot]=st[x],st[x]=tot,ed[tot]=y,cost[tot]=z;}struct node{ int x,d; inline node(int a,int b):x(a),d(b){} inline bool operator&lt;(const node&amp;t) const{return d&gt;t.d;}};priority_queue&lt;node&gt; q;int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1,x,y,z;i&lt;=m;i++) { scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); add(x,y,z); add(y,x,z); } int S=1,T=n; for(int i=1;i&lt;=n;i++) ds[i]=inf; q.push(node(S,0)); while(!q.empty()){ node x=q.top(); q.pop(); if(ds[x.x]&lt;inf) continue; ds[x.x]=x.d; for(int now=st[x.x];now;now=next[now]) q.push(node(ed[now],x.d+cost[now])); } printf(&quot;%d\\n&quot;,ds[T]);} æœ€å°ç”Ÿæˆæ ‘Kruskal O(E*logE)1234567891011121314151617181920212223242526272829303132#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;int n,m,x,y,z,f1,f2,tot,k,fa[1001];struct node{ int x,y,v;}a[10001];int cmp(const node &amp;a,const node &amp;b){ return a.v&lt;b.v;}int father(int x){ return fa[x]==x?x:fa[x]=father(fa[x]);}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) fa[i]=i; for(int i=1;i&lt;=m;i++) scanf(&quot;%d%d%d&quot;,&amp;a[i].x,&amp;a[i].y,&amp;a[i].v); sort(a+1,a+m+1,cmp); for(int i=1;i&lt;=m;i++) { x=a[i].x;y=a[i].y;z=a[i].v; f1=father(x);f2=father(y); if(f1==f2) continue; fa[f1]=f2;tot+=z;k++; if(k==n-1) break; } printf(&quot;%d&quot;,tot);} Prim1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;int n,m,x,y,z,tot,ans,k,ds[1001],next[2001],st[1001],to[2001],cost[2001];bool vis[1001];void addedge(int x,int y,int z){ next[++tot]=st[x];st[x]=tot;to[tot]=y;cost[tot]=z;}struct node{ int x,d; node(int a,int b):x(a),d(b) {} bool operator&lt;(const node&amp;t) const {return d&gt;t.d;}}; priority_queue&lt;node&gt;q;int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); addedge(x,y,z);addedge(y,x,z); } memset(ds,0x7f,sizeof(ds)); ds[1]=0;q.push(node(1,0));vis[0]=1; for(int i=1;i&lt;=n;i++) { node a(0,0); while(vis[a.x]&amp;&amp;!q.empty()) a=q.top(),q.pop(); if(vis[a.x]) break; ans+=a.d;vis[a.x]=1;k++; for(int j=st[a.x];j;j=next[j]) { y=to[j];z=cost[j]; if(!vis[y]&amp;&amp;z&lt;ds[y]) ds[y]=z,q.push(node(y,z)); } } if(k!=n) printf(&quot;-1&quot;); else printf(&quot;%d&quot;,ans);} çº¿æ®µæ ‘ O(nlogn)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int N=100;struct node{ int lc,rc,l,r,sum;}t[2*N]; int root,tot;int a[N];void build(int x,int l,int r){ t[x].l=l; t[x].r=r; if(l==r) { t[x].sum=a[l]; return; } int mid=(l+r)/2; t[x].lc=++tot; build(t[x].lc,l,mid); t[x].rc=++tot; build(t[x].rc,mid+1,r); t[x].sum=t[t[x].lc].sum+t[t[x].rc].sum;}int query(int x,int l,int r){ if(l&lt;=t[x].l&amp;&amp;t[x].r&lt;=r) return t[x].sum; int mid=(t[x].l+t[x].r)/2; int ans=0; if(l&lt;=mid) ans+=query(t[x].lc,l,r); if(mid&lt;r) ans+=query(t[x].rc,l,r); return ans;}void change(int x,int v,int d){ if(t[x].l==t[x].r) { t[x].sum=d; return; } int mid=(t[x].l+t[x].r)/2; if(v&lt;=mid) change(t[x].lc,v,d); if(mid&lt;v) change(t[x].rc,v,d); t[x].sum=t[t[x].lc].sum+t[t[x].rc].sum;}int main(){ int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); root=++tot; build(root,1,n); for(int i=1,k,x,y;i&lt;=m;i++) { scanf(&quot;%d%d%d&quot;,&amp;k,&amp;x,&amp;y); if(k==1) printf(&quot;%d\\n&quot;,query(root,x,y)); if(k==2) change(root,x,y); } } æ ‘çŠ¶æ•°ç»„ O(nlogn)123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;int a[10001],c[10001];int n;int lowbit(int x){ return x&amp;(-x);}void build(){ for(int i=1;i&lt;=n;i++) { c[i]=a[i]; for(int j=i-1;j&gt;i-lowbit(i);j-=lowbit(j)) c[i]+=c[j]; }}int sum(int x) //æ±‚xä¹‹å‰çš„å’Œ { int sum=0; for(;x;x-=lowbit(x)) sum+=c[x]; return sum;}void change(int x,int y) //æŠŠa[x]åŠ y { for(;x&lt;=n;x+=lowbit(x)) c[x]+=y;} tarjan O(n+m)1234567891011121314151617181920212223242526void Tarjan(int i){ int j; dfn[i]=low[i]=++tot; vis[i]=1; stack[++top]=i; for(int e=0;e&lt;to[i].size();e++) { j=to[i][e]; if(!dfn[j]) { Tarjan(j); if(low[j]&lt;low[i]) low[i]=low[j]; } else if(vis[j]&amp;&amp;dfn[j]&lt;low[i]) low[i]=dfn[j]; } if(dfn[i]==low[i]) { do { j=stack[top--]; fa[j]=fa[i]; vis[j]=0; }while(j!=i); }} Lca123456789101112131415161718192021æ³¨æ„dep[1]=1;for(int i=1;i&lt;=log(n)/log(2)+1;i++) for(int j=1;j&lt;=n;j++) fa[j][i]=fa[fa[j][i-1]][i-1], //g[j][i]=max(g[j][i-1],g[fa[j][i-1]][i-1]);int lca(int x,int y){ //int ans=0; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=log(n)/log(2);i&gt;=0;i--) if(dep[fa[x][i]]&gt;=dep[y]) //ans=max(ans,g[x][i]), x=fa[x][i]; if(x==y) return x; for(int i=log(n)/log(2);i&gt;=0;i--) if(fa[x][i]!=fa[y][i]) //ans=max(ans,g[x][i]),ans=max(ans,g[y][i]), x=fa[x][i],y=fa[y][i]; //ans=max(ans,g[x][0]);ans=max(ans,g[y][0]); return fa[x][0];} çŸ©é˜µä¹˜æ³•123456789101112131415161718192021222324252627282930313233343536long long multi(long long y,long long cnt) //å¿«é€Ÿä¹˜ { if (!cnt) return 0; if (cnt==1) return y%m; long long rec=multi(y,cnt/2); rec=(rec+rec)%m; if(cnt%2) rec=(rec+y)%m; return rec;}void cheng(int x){ X[1][1]=0;X[1][2]=0;X[2][1]=0;X[2][2]=0; if(x==0) { for(int i=1;i&lt;=2;i++) for(int j=1;j&lt;=2;j++) for(int k=1;k&lt;=2;k++) X[i][j]=(X[i][j]+multi(A[i][k],N[k][j]))%m; swap(X,N); } else { for(int i=1;i&lt;=2;i++) for(int j=1;j&lt;=2;j++) for(int k=1;k&lt;=2;k++) X[i][j]=(X[i][j]+multi(N[i][k],N[k][j]))%m; swap(X,N); }}void mi(long long n){ if(n==1) return; mi(n/2); cheng(1);//N*N if(n%2) cheng(0);//N*A} åŒˆç‰™åˆ©ç®—æ³•123456789101112131415161718192021222324252627282930int used[N]; //è®°å½•yä¸­èŠ‚ç‚¹æ˜¯å¦ä½¿ç”¨ 0è¡¨ç¤ºæ²¡æœ‰è®¿é—®è¿‡ï¼Œ1ä¸ºè®¿é—®è¿‡int linker[N]; //è®°å½•å½“å‰ä¸yèŠ‚ç‚¹ç›¸è¿çš„xçš„èŠ‚ç‚¹ int g[N][N]; //è®°å½•è¿æ¥xå’Œyçš„è¾¹ï¼Œå¦‚æœiå’Œjä¹‹é—´æœ‰è¾¹åˆ™ä¸º1ï¼Œå¦åˆ™ä¸º0int vn,vm; //äºŒåˆ†å›¾ä¸­xå’Œyä¸­ç‚¹çš„æ•°ç›® bool dfs(int u)//ä»å·¦è¾¹å¼€å§‹æ‰¾å¢å¹¿è·¯å¾„{ for(int v=0;v&lt;vN;v++)//è¿™ä¸ªé¡¶ç‚¹ç¼–å·ä»0å¼€å§‹ï¼Œè‹¥è¦ä»1å¼€å§‹éœ€è¦ä¿®æ”¹ if(g[u][v]&amp;&amp;!used[v]) { used[v]=true; if(linker[v]==-1||dfs(linker[v])) {//æ‰¾å¢å¹¿è·¯ï¼Œåå‘ linker[v]=u; return true; } } return false;//è¿™ä¸ªä¸è¦å¿˜äº†ï¼Œç»å¸¸å¿˜è®°è¿™å¥}int hungary(){ int res=0; int u; memset(linker,-1,sizeof(linker)); for(u=0;u&lt;uN;u++) { memset(used,0,sizeof(used)); if(dfs(u)) res++; } return res;} Dinic123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#define LINK(x) for(int e=head[x];e;e=E[e].next)using namespace std;const int N=5000;const int M=10000;const int inf=1e9;struct Edge{int to,rest,next;}E[M];queue&lt;int&gt; Q;int head[N],ds[N];int n,m,S,T,ecnt=1;inline void AddEdge(int x,int y,int r){ ++ecnt;E[ecnt].to=y,E[ecnt].rest=r,E[ecnt].next=head[x];head[x]=ecnt; ++ecnt;E[ecnt].to=x,E[ecnt].rest=0,E[ecnt].next=head[y];head[y]=ecnt;}inline bool BFS(){ //static queue&lt;int&gt; Q; //static å…¨å±€å˜é‡ for(int i=S;i&lt;=T;i++) ds[i]=-1; Q.push(S);ds[S]=0; while(!Q.empty()) { int x=Q.front(); Q.pop(); LINK(x) if(E[e].rest &amp;&amp; ds[E[e].to]==-1) ds[E[e].to]=ds[x]+1,Q.push(E[e].to); } return ds[T]&gt;-1;}inline int DFS(int x,int flow){ if(x==T) return flow; int a=0,b; LINK(x) if(E[e].rest&amp;&amp;ds[E[e].to]==ds[x]+1) { b=DFS(E[e].to, min(flow-a,E[e].rest)); E[e].rest-=b, E[e^1].rest+=b; a+=b; if(a==flow) return flow; } if(a==0) ds[x]=-1; return a;}inline int dinic(){ int ans=0; while(BFS()) ans+=DFS(S,inf); return ans;}int main(){ scanf(&quot;%d%d%d&quot;,&amp;m,&amp;S,&amp;T); for(int i=1;i&lt;=m;i++) { int u,v,c; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;c); AddEdge(u,v,c); } printf(&quot;%d\\n&quot;,dinic()); return 0;}","link":"/2021/08/04/noip%E6%A8%A1%E6%9D%BF/"},{"title":"Round A 2021 - Kick Start 2021","text":"","link":"/2021/08/05/Round%20A%202021%20-%20Kick%20Start%202021/"},{"title":"æ°¸è¿œæƒ³å¿µ2021å¹´å¤å¤©","text":"å—äº¬-å®‰å‰-æ­å·-ä¹Œé•‡-ä¸Šæµ·-è‹å· ![IMG_4509](/images/2021å¹´çš„å¤å¤©/IMG_4509.JPG) ![IMG_4655](C:/Blog/blog/public/images/2021å¹´çš„å¤å¤©/IMG_4655.JPG) ![IMG_4739](C:\\Blog\\blog\\public\\images\\2021å¹´çš„å¤å¤©\\IMG_4739.JPG) ![IMG_4751](C:\\Blog\\blog\\public\\images\\2021å¹´çš„å¤å¤©\\IMG_4751.JPG) ![IMG_4752](C:\\Blog\\blog\\public\\images\\2021å¹´çš„å¤å¤©\\IMG_4752.JPG) ![IMG_4754](C:\\Blog\\blog\\public\\images\\2021å¹´çš„å¤å¤©\\IMG_4754.JPG) ![IMG_4755](C:\\Blog\\blog\\public\\images\\2021å¹´çš„å¤å¤©\\IMG_4755.JPG) ![IMG_4756](C:\\Blog\\blog\\public\\images\\2021å¹´çš„å¤å¤©\\IMG_4756.JPG) ![IMG_4767](C:\\Blog\\blog\\public\\images\\2021å¹´çš„å¤å¤©\\IMG_4767.JPG) ![IMG_4786](C:\\Blog\\blog\\public\\images\\2021å¹´çš„å¤å¤©\\IMG_4786.JPG) ![IMG_4823](C:\\Blog\\blog\\public\\images\\2021å¹´çš„å¤å¤©\\IMG_4823.JPG) ![IMG_5023](C:\\Blog\\blog\\public\\images\\2021å¹´çš„å¤å¤©\\IMG_5023.JPG) ![IMG_5035](C:\\Blog\\blog\\public\\images\\2021å¹´çš„å¤å¤©\\IMG_5035.JPG) ![IMG_5036](C:\\Blog\\blog\\public\\images\\2021å¹´çš„å¤å¤©\\IMG_5036.JPG) ![IMG_5048](C:\\Blog\\blog\\public\\images\\2021å¹´çš„å¤å¤©\\IMG_5048.JPG) ![IMG_5057](C:\\Blog\\blog\\public\\images\\2021å¹´çš„å¤å¤©\\IMG_5057.JPG) ![IMG_5060](C:\\Blog\\blog\\public\\images\\2021å¹´çš„å¤å¤©\\IMG_5060.JPG) ![IMG_5065](C:\\Blog\\blog\\public\\images\\2021å¹´çš„å¤å¤©\\IMG_5065.JPG) ![IMG_5105](C:\\Blog\\blog\\public\\images\\2021å¹´çš„å¤å¤©\\IMG_5105.JPG) ![IMG_5107](C:\\Blog\\blog\\public\\images\\2021å¹´çš„å¤å¤©\\IMG_5107.JPG) ![IMG_5132](C:\\Blog\\blog\\public\\images\\2021å¹´çš„å¤å¤©\\IMG_5132.JPG) ![IMG_5138](C:\\Blog\\blog\\public\\images\\2021å¹´çš„å¤å¤©\\IMG_5138.JPG) ![IMG_5140](C:\\Blog\\blog\\public\\images\\2021å¹´çš„å¤å¤©\\IMG_5140.JPG) ![IMG_5162](C:\\Blog\\blog\\public\\images\\2021å¹´çš„å¤å¤©\\IMG_5162.JPG) ![IMG_5255](C:\\Blog\\blog\\public\\images\\2021å¹´çš„å¤å¤©\\IMG_5255.JPG) ![IMG_5265](C:\\Blog\\blog\\public\\images\\2021å¹´çš„å¤å¤©\\IMG_5265.JPG) ![IMG_5274](C:\\Blog\\blog\\public\\images\\2021å¹´çš„å¤å¤©\\IMG_5274.JPG) ![IMG_5314](C:\\Blog\\blog\\public\\images\\2021å¹´çš„å¤å¤©\\IMG_5314.JPG) ![IMG_5335](C:\\Blog\\blog\\public\\images\\2021å¹´çš„å¤å¤©\\IMG_5335.JPG) ![IMG_5342](C:\\Blog\\blog\\public\\images\\2021å¹´çš„å¤å¤©\\IMG_5342.JPG)","link":"/2021/08/19/2021%E5%B9%B4%E5%A4%8F%E5%A4%A9/"}],"tags":[{"name":"Movies","slug":"Movies","link":"/tags/Movies/"},{"name":"Kick Start","slug":"Kick-Start","link":"/tags/Kick-Start/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Coding Competitions","slug":"Coding-Competitions","link":"/tags/Coding-Competitions/"},{"name":"Noip","slug":"Noip","link":"/tags/Noip/"},{"name":"ShotoniPhone","slug":"ShotoniPhone","link":"/tags/ShotoniPhone/"},{"name":"traveling","slug":"traveling","link":"/tags/traveling/"}],"categories":[{"name":"Life","slug":"Life","link":"/categories/Life/"},{"name":"Work","slug":"Work","link":"/categories/Work/"},{"name":"Movies","slug":"Life/Movies","link":"/categories/Life/Movies/"},{"name":"Coding","slug":"Work/Coding","link":"/categories/Work/Coding/"},{"name":"Kick Start","slug":"Work/Coding/Kick-Start","link":"/categories/Work/Coding/Kick-Start/"},{"name":"Photography","slug":"Life/Photography","link":"/categories/Life/Photography/"}]}