{"pages":[],"posts":[{"title":"STL简介","text":"C++ STL教程所有常用操作都在代码里STL可能会很慢，时间允许的话可替代操作还是手写好建议对每一种都盲敲2~3遍代码，不要眼高手低 Vector1234567891011121314#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;//！！！头文件using namespace std;vector&lt;int&gt; a[100];int main(){ for(int i=1;i&lt;=200;i++) a[1].push_back(i);//插入 a[1].pop_back();//弹出 cout&lt;&lt;a[1].size()&lt;&lt;endl;//大小 for(int i=0;i&lt;199;i++) cout&lt;&lt;a[1][i]&lt;&lt;endl; } MapMap是c++的一个标准容器，按字面意思就是地图的意思即给你一个元素，根据“地图”找到这个元素对应的元素 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 /*头文件&lt;map&gt;*/#include &lt;map&gt;#include &lt;iostream&gt;using namespace std;int main(){ map&lt;string,int&gt; a; cout&lt;&lt;&quot;插入:&quot;&lt;&lt;endl; a[&quot;April&quot;]=112;//插入 cout&lt;&lt;a[&quot;April&quot;]&lt;&lt;endl; cout&lt;&lt;endl; cout&lt;&lt;&quot;查询:&quot;&lt;&lt;endl; map&lt;string,int&gt;::iterator pc;//查询一个元素是否在map里 pc=a.find(&quot;April&quot;); if(pc==a.end()) cout&lt;&lt;&quot;Not Find&quot;&lt;&lt;endl;//如果找不到会自动返回“指向map尾部的迭代器” else cout&lt;&lt;pc-&gt;second&lt;&lt;endl;//输出&quot;April&quot;对应的键值 cout&lt;&lt;endl; cout&lt;&lt;&quot;遍历&quot;&lt;&lt;endl; a[&quot;June&quot;]=1;//遍历 a[&quot;July&quot;]=2; map&lt;string,int&gt;::iterator i; for(i=a.begin(); i!=a.end(); i++)//不能等于a.end() { cout&lt;&lt;i-&gt;second&lt;&lt;endl; } cout&lt;&lt;endl; cout&lt;&lt;&quot;判断map是否是空集&quot;&lt;&lt;endl; cout&lt;&lt;a.empty()&lt;&lt;endl;//判断map是否是空集 cout&lt;&lt;endl; cout&lt;&lt;&quot;交换两个map的元素 &quot;&lt;&lt;endl; map&lt;int ,int&gt; b;//交换两个map的元素 map&lt;int ,int&gt; c; c[1]=1; c[2]=2; b[1]=1000; swap(b,c); map&lt;int,int&gt; ::iterator j; for(j=b.begin();j!=b.end();j++) { cout&lt;&lt;j-&gt;second&lt;&lt;endl; } for(j=c.begin();j!=c.end();j++) { cout&lt;&lt;j-&gt;second&lt;&lt;endl; } } map中 swap的用法： Map中的swap不是一个容器中的元素交换，而是两个容器交换； Map中的元素是自动按key升序排序 123456789101112131415161718192021222324252627 #include &lt;map&gt; #include &lt;iostream&gt; using namespace std; int main( ) { map &lt;int, int&gt; m1; map &lt;int, int&gt;::iterator m1_Iter; m1[1]=20; m1[4]=40; m1[3]=60; m1[2]=50; m1[6]=40; m1[7]=30; cout &lt;&lt; &quot;The original map m1 is:&quot;&lt;&lt;endl; for ( m1_Iter = m1.begin( ); m1_Iter != m1.end( ); m1_Iter++ ) cout &lt;&lt; m1_Iter-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;m1_Iter-&gt;second&lt;&lt;endl;}/*The original map m1 is: 1 20 2 50 3 60 4 40 6 40 7 30*/ map的基本操作函数： 12345678910111213141516171819begin() 返回指向map头部的迭代器clear(） 删除所有元素count() 返回指定元素出现的次数empty() 如果map为空则返回trueend() 返回指向map末尾的迭代器*equal_range() 返回特殊条目的迭代器对erase() 删除一个元素find() 查找一个元素get_allocator() 返回map的配置器insert() 插入元素key_comp() 返回比较元素key的函数lower_bound() 返回键值&gt;=给定元素的第一个位置max_size() 返回可以容纳的最大元素个数rbegin() 返回一个指向map尾部的逆向迭代器rend() 返回一个指向map头部的逆向迭代器size() 返回map中元素的个数swap() 交换两个mapupper_bound() 返回键值&gt;给定元素的第一个位置value_comp() 返回比较元素value的函数 Set set作为一个容器也是用来存储同一数据类型的数据类型，并且能从一个数据集合中取出数据，在set中每个元素的值都唯一，而且系统能根据元素的值自动进行排序。应该注意的是set中数元素的值不能直接被改变。 set中常用的方法 1234567begin() 返回set容器的第一个元素end() 返回set容器的最后一个元素clear() 删除set容器中的所有的元素empty() 判断set容器是否为空size() 返回当前set容器中的元素个数count() 用来查找set中某个某个键值出现的次数。这个函数在set并不是很实用，因为一个键值在set只可能出现0或1次，这样就变成了判断某一键值是否在set出现过了。find() ，返回给定值值得定位器，如果没找到则返回end()。 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int main(){ set&lt;int&gt; s; s.insert(1); s.insert(2); s.insert(3); s.insert(1); cout&lt;&lt;&quot;set 的 size 值为 ：&quot;&lt;&lt;s.size()&lt;&lt;endl; cout&lt;&lt;&quot;set 的 maxsize的值为 ：&quot;&lt;&lt;s.max_size()&lt;&lt;endl; cout&lt;&lt;&quot;set 中的第一个元素是 ：&quot;&lt;&lt;*s.begin()&lt;&lt;endl; cout&lt;&lt;&quot;set 中的最后一个元素是:&quot;&lt;&lt;*s.end()&lt;&lt;endl; s.clear(); if(s.empty()) { cout&lt;&lt;&quot;set 为空 ！！！&quot;&lt;&lt;endl; } cout&lt;&lt;&quot;set 的 size 值为 ：&quot;&lt;&lt;s.size()&lt;&lt;endl; cout&lt;&lt;&quot;set 的 maxsize的值为 ：&quot;&lt;&lt;s.max_size()&lt;&lt;endl; return 0;} lower_bound(key_value) ，返回第一个大于等于key_value的定位器 upper_bound(key_value)，返回最后一个大于等于key_value的定位器 12345678910111213141516#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int main(){ set&lt;int&gt; s; s.insert(1); s.insert(3); s.insert(4); cout&lt;&lt;*s.lower_bound(2)&lt;&lt;endl; cout&lt;&lt;*s.lower_bound(3)&lt;&lt;endl; cout&lt;&lt;*s.upper_bound(3)&lt;&lt;endl; return 0;} useful link about set Queue普通队列大家都会写吧 我们来看看如何用queue来实现堆的功能 1234567891011121314151617//小根堆 #include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q;//默认是大根堆，小根堆需要自己加greater&lt;int&gt;int main(){ q.push(1); q.push(2); q.push(3); while(q.size()) { cout&lt;&lt;q.top()&lt;&lt;endl; q.pop(); }} 1234567891011121314151617//大根堆 #include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;priority_queue&lt;int&gt;q;int main(){ q.push(1); q.push(2); q.push(3); while(q.size()) { cout&lt;&lt;q.top()&lt;&lt;endl; q.pop(); }} Bitsetbitset可以看作bool数组，但优化了空间复杂度和时间复杂度，并且可以像整型一样按位与或。 123456789101112131415161718#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;bitset&gt;using namespace std;bitset&lt;10&gt; a;//&lt;&gt;中间是长度！！！bitset&lt;10&gt; b;int main(){ a.set();//全部置为1 cout&lt;&lt;a&lt;&lt;endl; a.reset();//全部置为0 a[1]=1;//可以直接把它当作一个数来进行二进制操作 a=a|b; cout&lt;&lt;a.count()&lt;&lt;endl; //输出bitset里有多少个1 cout&lt;&lt;a&lt;&lt;endl; a.flip();//将bitset里的元素翻转一下 cout&lt;&lt;a;} &lt;&gt;中间是长度！！！ bitset空间占用十分小，运行速度也很快！！奇技淫巧 常用的成员函数： 12345678910111213141516b.any() b中是否存在置为1的二进制位？b.none() b存在置为1的二进制位吗？b.count() b中置为1的二进制位的个数b.size() b中二进制位数的个数b[pos] 访问b中在pos处二进制位b.test(pos) b中在pos处的二进制位置为1么？b.set() 把b中所有二进制位都置为1b.set(pos) 把b中在pos处的二进制位置为1b.reset( ) 把b中所有二进制位都置为0b.reset( pos ) 把b中在pos处的二进制位置置为0b.flip( ) 把b中所有二进制位逐位取反b.flip( pos ) 把b中在pos处的二进制位取反b.to_ulong( ) 把b中同样的二进制位返回一个unsignedb._Find_next(pos) 返回bitset在位置pos之后第一个1的位置 useful link about Bitset lower_bound&amp;upper_bound 函数lower_bound()在first和last中的前闭后开区间进行二分查找，返回大于或等于**val的第一个元素位置。如果所有元素都小于val，则返回last的位置用法： int t=lower_bound(a+l,a+r,m)-a 函数upper_bound()在first和last中的前闭后开区间进行二分查找，返回大于val的第一个元素位置。如果所有元素都小于val，则返回last的位置复杂度O(logn)","link":"/2021/07/30/STL/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/07/30/hello-world/"},{"title":"test_my_site","text":"","link":"/2021/07/30/test-my-site/"}],"tags":[{"name":"noip","slug":"noip","link":"/tags/noip/"}],"categories":[{"name":"coding","slug":"coding","link":"/categories/coding/"}]}